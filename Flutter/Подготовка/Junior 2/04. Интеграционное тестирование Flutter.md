# Лекция 4: Интеграционное тестирование в Flutter  
## Назначение и возможности интеграционного тестирования  

### Что такое интеграционные тесты?  
Интеграционные тесты — это вид автоматизированных тестов, которые проверяют взаимодействие между компонентами приложения. В контексте Flutter они направлены на тестирование сложных сценариев, включающих несколько виджетов, сервисов, баз данных и внешних зависимостей (например, API).  

### Цели интеграционного тестирования  
1. **Проверка корректности взаимодействия компонентов**: Убедиться, что данные правильно передаются между модулями приложения (например, от формы ввода к серверу, затем к локальному хранению).  
2. **Тестирование пользовательского интерфейса**: Проверить, как меняется UI в ответ на действия пользователя (нажатие кнопки, ввод текста, загрузка данных).  
3. **Обнаружение ошибок при совместной работе компонентов**: Например, проверить, что после успешного входа пользователь переходит на другую страницу.  
4. **Убедиться в корректности использования сторонних библиотек или API**: Например, тестировать, как приложение реагирует на ошибки сети или несоответствие формата ответа от сервера.  

### Возможности интеграционного тестирования в Flutter  
- **Работа с реальными и моковыми сервисами**: Можно использовать моки для имитации API, чтобы избежать зависимости от внешних систем во время тестирования.  
- **Проверка сложных пользовательских потоков**: Например, тестирование процесса покупки товара в приложении (от добавления товара в корзину до подтверждения заказа).  
- **Поддержка асинхронных операций**: Интеграционные тесты могут проверять загрузку данных с сервера, обработку ошибок сети и сохранение информации в базе.  
- **Тестирование UI на разных устройствах и ориентациях экрана**: Flutter позволяет эмулировать разные размеры экранов и режимы (портретный/пейзажный).  

### Пример использования интеграционного тестирования  
Рассмотрим приложение, которое загружает список задач с сервера. Интеграционный тест может проверить:  
- Контейнер для отображения задач правильно отображается.  
- При ошибке сети выводится сообщение об ошибке.  
- После успешной загрузки все элементы списка корректно отображаются.  

---

## Написание интеграционных тестов в Flutter  

### Основные инструменты и библиотеки  
Для интеграционного тестирования в Flutter используется пакет `flutter_test` (входит в состав Flutter SDK) и его подмодуль `integration_test`.  

### Подготовка проекта для интеграционных тестов  
1. В корне проекта создайте директорию `test/integration`.  
2. Добавьте файлы с тестами, например: `test/integration/login_screen_test.dart`.  
3. Убедитесь, что в `pubspec.yaml` указано:  
```yaml
dev_dependencies:
  flutter_test:
    sdk: flutter
```

### Основные шаги для написания теста  
1. **Импортирование библиотек**: Используйте `package:flutter_test/flutter_test.dart`.  
2. **Создание тестовой функции**: Функция начинается с `testWidgets`, где указывается описание теста и блок кода для проверки.  
3. **Настройка окружения**: Используйте `WidgetTester` для взаимодействия с виджетами.  

### Пример 1: Тестирование навигации  
```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter/material.dart';

void main() {
  testWidgets('Тест на навигацию при нажатии кнопки', (WidgetTester tester) async {
    // Создание тестового виджета с кнопкой
    await tester.pumpWidget(MaterialApp(
      home: Center(child: ElevatedButton(onPressed: () => Navigator.of(context).pushNamed('/next'), child: Text('Перейти'))),
    ));

    // Нажатие на кнопку
    await tester.tap(find.text('Перейти'));
    await tester.pumpAndSettle();

    // Проверка, что маршрут '/next' был открыт
    expect(tester.routerDelegate.currentConfiguration, equals('/next'));
  });
}
```
**Комментарии**:  
- `pumpWidget` — загружает виджет в тестовую среду.  
- `tap` — имитирует нажатие на элемент (в данном случае кнопку).  
- `routerDelegate.currentConfiguration` — проверяет, был ли открыт маршрут `/next`.  

### Пример 2: Тестирование формы ввода и валидации  
```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter/material.dart';

void main() {
  testWidgets('Тест валидации формы', (WidgetTester tester) async {
    await tester.pumpWidget(MaterialApp(
      home: Scaffold(
        body: Column(
          children: [
            TextField(
              validator: (value) {
                if (value == null || value.isEmpty) return 'Поле обязательно';
                return null;
              },
            ),
            ElevatedButton(
              onPressed: () {},
              child: Text('Отправить'),
            ),
          ],
        ),
      ),
    ));

    // Нажатие на кнопку отправки
    await tester.tap(find.text('Отправить'));
    await tester.pumpAndSettle();

    // Проверка, отображается ли сообщение об ошибке
    expect(find.text('Поле обязательно'), findsOneWidget);
  });
}
```
**Комментарии**:  
- `validator` в `TextField` проверяет корректность ввода.  
- После нажатия кнопки тест проверяет, отображается ли сообщение об ошибке.  

### Использование моков для сервисов  
Для имитации внешних зависимостей (например, API) используется пакет `mockito`. Пример:  
```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:http/http.dart' as http;
import 'package:mockito/mock.dart';
import 'dart:convert';

class MockClient extends Mock implements http.Client {}

void main() {
  final mockClient = MockClient();
  when(mockClient.get(Uri.parse('https://api.example.com/data')))
      .thenAnswer((_) async => http.Response(jsonEncode({'data': 'test'}), 200));

  testWidgets('Тест загрузки данных из API', (WidgetTester tester) async {
    await tester.pumpWidget(MaterialApp(
      home: Scaffold(
        body: FutureBuilder(
          future: http.get(Uri.parse('https://api.example.com/data'), client: mockClient),
          builder: (context, snapshot) {
            if (snapshot.hasData) return Text(snapshot.data!.body);
            return Text('Загрузка...');
          },
        ),
      ),
    ));

    await tester.pumpAndSettle();
    expect(find.text('test'), findsOneWidget);
  });
}
```
**Комментарии**:  
- `MockClient` имитирует HTTP-запросы.  
- `when(...).thenAnswer(...)` задаёт возвращаемое значение для мока.  

---

## Запуск интеграционных тестов  

### Команды Flutter для запуска тестов  
1. **Запуск всех интеграционных тестов**:  
```bash
flutter test test/integration
```
2. **Запуск конкретного теста**:  
```bash
flutter test test/integration/login_screen_test.dart
```
3. **При запуске на устройстве или эмуляторе** (необходимо добавить флаг `--device-id`):  
```bash
flutter test --device-id=<id_устройства> test/integration
```

### Настройка окружения для тестирования  
- Убедитесь, что в `test/integration` есть файл `integration_test.dart`. Этот файл содержит глобальные настройки и может использоваться для регистрации моков или загрузки конфигурации.  
- Для работы с реальными API во время тестирования используйте флаги:  
```bash
--use-test-fonts --dart-define=FLUTTER_WEB_USE_SKIA=true
```

### Обработка ошибок и улучшение производительности  
- **Используйте `pumpAndSettle()`**: Она позволяет дождаться завершения всех асинхронных операций (например, загрузки данных с сервера).  
- **Логирование**: Добавьте `print` или `debugPrint` в тесты для отладки.  
- **Используйте моки вместо реальных API**: Это ускоряет выполнение тестов и упрощает их запуск.  

---

## Практическое задание  
### Задача: Тестирование процесса авторизации пользователя  
**Требования**:  
1. Реализуйте в приложении экран входа с полями логина и пароля, кнопкой "Войти" и отображением ошибок (например, "Неверный логин или пароль").  
2. Напишите интеграционный тест, который:  
   - Проверяет, что при вводе пустого логина и нажатии на кнопку "Войти" отображается сообщение об ошибке.  
   - При успешном входе (правильные данные) пользователь переходит на следующий экран.  

**Подсказки**:  
- Используйте `TextField` с валидатором для проверки пустых полей.  
- Для моков API используйте `mockito`, чтобы имитировать успешную авторизацию.  

---

## Контрольные вопросы по теме  
1. **Чем отличаются интеграционные тесты от юнит-тестов в Flutter?**  
   - Интеграционные тесты проверяют взаимодействие компонентов, а юнит-тесты — отдельные функции или методы.  

2. **Какие библиотеки используются для написания интеграционных тестов в Flutter?**  
   - `flutter_test` и его подмодуль `integration_test`.  

3. **Каким образом можно имитировать внешние зависимости (например, API) во время тестирования?**  
   - Используя моки через пакет `mockito`.  

4. **Какие команды Flutter используются для запуска интеграционных тестов?**  
   - `flutter test test/integration` и `flutter test <путь_к_файлу>`.  

5. **Как проверить, что приложение корректно обрабатывает ошибки сети в интеграционном тесте?**  
   - Используйте моки для имитации ответа сервера с кодом 500 и проверяйте отображение сообщений об ошибке.  

---

## Список литературы и ссылки  
1. **Официальная документация Flutter**: [https://docs.flutter.dev/testing/integration-tests](https://docs.flutter.dev/testing/integration-tests)  
2. **Книга: "Flutter in Action" (Second Edition)** — содержит главы о тестировании и мокировании.  
3. **Статья на Medium: "Testing Flutter Apps with Integration Tests"** — [https://medium.com/@mohamed_abdelhameed/testing-flutter-apps-with-integration-tests-6b5d8a4f7e0c](https://medium.com/@mohamed_abdelhameed/testing-flutter-apps-with-integration-tests-6b5d8a4f7e0c)  
4. **Пакет `mockito` (для моков)**: [https://pub.dev/packages/mockito](https://pub.dev/packages/mockito)  
5. **Примеры тестов на GitHub**: [https://github.com/flutter/flutter/tree/master/dev/integration_tests](https://github.com/flutter/flutter/tree/master/dev/integration_tests)  

---

## Дополнительные советы и лучшие практики  
- **Используйте `find.byKey` вместо `find.text`**: Это делает тесты более устойчивыми к изменениям UI.  
- **Тестируйте только ключевые пользовательские сценарии**, а не все возможные комбинации (например, не проверяйте каждый путь в приложении).  
- **Используйте `setUp` и `tearDown`**: Для подготовки и очистки тестовой среды.  
- **Фокусируйтесь на UI-тестах**, а логику бизнеса проверяйте юнит-тестами.  

Следуя этим рекомендациям, вы сможете создавать надёжные и эффективные интеграционные тесты для ваших Flutter-приложений!