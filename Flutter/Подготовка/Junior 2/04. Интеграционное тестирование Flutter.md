<think>
Okay, so I need to create a detailed lecture on integration testing in Flutter for a Junior developer. The user wants it self-contained and comprehensive, with examples in Dart and Flutter. Let's start by breaking down the main topics: purpose and capabilities of integration testing, writing tests, running them, then practical tasks, control questions, and references.

First, I need to explain what integration testing is. For a Flutter developer, this means testing how different parts of the app work together, like widgets, services, or even external APIs. Unlike unit tests that focus on individual functions, integration tests check the entire flow. Maybe mention that they're more end-to-end but not as comprehensive as full E2E tests.

Next, the purpose and capabilities. Highlight that integration tests verify user interactions, data flows between components, UI correctness across different states, and ensure that the app behaves correctly with real dependencies (like network calls or local storage). Also, mention that they can use real or mock services, which is useful for testing without relying on external APIs.

Then, writing integration tests. I should explain using the flutter_test package's integration test framework. Maybe start with an example of a simple widget and how to write a test for it. Use the WidgetTester class, maybe show how to pump widgets, trigger events, and assert states. Also discuss mocking dependencies like HTTP requests with http:mock or mockito.

Examples are crucial here. Provide code snippets with explanations. For instance, a test that checks if a button click navigates to another screen, ensuring that the correct route is pushed. Another example could involve testing a form submission, checking validation messages and state changes.

Running tests section should cover how to execute them using flutter drive command, setting up the test environment (like using --target), handling different platforms (Android/iOS), and possible issues like slow tests or dependency setup.

Practical task: Maybe create a test for a login screen that verifies navigation after successful login. Control questions could be about differences between unit and integration tests, tools used, how to mock APIs, etc.

References would include the official Flutter documentation on testing, books on Flutter testing, and maybe some articles or blogs that go deeper into advanced topics.

Wait, I need to make sure all parts are covered thoroughly. Let me structure each section step by step, ensuring examples are detailed with comments explaining each line. Also, check if there are any best practices specific to Flutter integration tests that should be mentioned, like using TestWidgetsFlutterBinding and understanding the test lifecycle.
</think>

# Лекция 4: Интеграционное тестирование в Flutter  
## Назначение и возможности интеграционного тестирования  

### Что такое интеграционные тесты?  
Интеграционные тесты — это вид автоматизированных тестов, которые проверяют взаимодействие между компонентами приложения. В контексте Flutter они направлены на тестирование сложных сценариев, включающих несколько виджетов, сервисов, баз данных и внешних зависимостей (например, API).  

### Цели интеграционного тестирования  
1. **Проверка корректности взаимодействия компонентов**: Убедиться, что данные правильно передаются между модулями приложения (например, от формы ввода к серверу, затем к локальному хранению).  
2. **Тестирование пользовательского интерфейса**: Проверить, как меняется UI в ответ на действия пользователя (нажатие кнопки, ввод текста, загрузка данных).  
3. **Обнаружение ошибок при совместной работе компонентов**: Например, проверить, что после успешного входа пользователь переходит на другую страницу.  
4. **Убедиться в корректности использования сторонних библиотек или API**: Например, тестировать, как приложение реагирует на ошибки сети или несоответствие формата ответа от сервера.  

### Возможности интеграционного тестирования в Flutter  
- **Работа с реальными и моковыми сервисами**: Можно использовать моки для имитации API, чтобы избежать зависимости от внешних систем во время тестирования.  
- **Проверка сложных пользовательских потоков**: Например, тестирование процесса покупки товара в приложении (от добавления товара в корзину до подтверждения заказа).  
- **Поддержка асинхронных операций**: Интеграционные тесты могут проверять загрузку данных с сервера, обработку ошибок сети и сохранение информации в базе.  
- **Тестирование UI на разных устройствах и ориентациях экрана**: Flutter позволяет эмулировать разные размеры экранов и режимы (портретный/пейзажный).  

### Пример использования интеграционного тестирования  
Рассмотрим приложение, которое загружает список задач с сервера. Интеграционный тест может проверить:  
- Контейнер для отображения задач правильно отображается.  
- При ошибке сети выводится сообщение об ошибке.  
- После успешной загрузки все элементы списка корректно отображаются.  

---

## Написание интеграционных тестов в Flutter  

### Основные инструменты и библиотеки  
Для интеграционного тестирования в Flutter используется пакет `flutter_test` (входит в состав Flutter SDK) и его подмодуль `integration_test`.  

### Подготовка проекта для интеграционных тестов  
1. В корне проекта создайте директорию `test/integration`.  
2. Добавьте файлы с тестами, например: `test/integration/login_screen_test.dart`.  
3. Убедитесь, что в `pubspec.yaml` указано:  
```yaml
dev_dependencies:
  flutter_test:
    sdk: flutter
```

### Основные шаги для написания теста  
1. **Импортирование библиотек**: Используйте `package:flutter_test/flutter_test.dart`.  
2. **Создание тестовой функции**: Функция начинается с `testWidgets`, где указывается описание теста и блок кода для проверки.  
3. **Настройка окружения**: Используйте `WidgetTester` для взаимодействия с виджетами.  

### Пример 1: Тестирование навигации  
```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter/material.dart';

void main() {
  testWidgets('Тест на навигацию при нажатии кнопки', (WidgetTester tester) async {
    // Создание тестового виджета с кнопкой
    await tester.pumpWidget(MaterialApp(
      home: Center(child: ElevatedButton(onPressed: () => Navigator.of(context).pushNamed('/next'), child: Text('Перейти'))),
    ));

    // Нажатие на кнопку
    await tester.tap(find.text('Перейти'));
    await tester.pumpAndSettle();

    // Проверка, что маршрут '/next' был открыт
    expect(tester.routerDelegate.currentConfiguration, equals('/next'));
  });
}
```
**Комментарии**:  
- `pumpWidget` — загружает виджет в тестовую среду.  
- `tap` — имитирует нажатие на элемент (в данном случае кнопку).  
- `routerDelegate.currentConfiguration` — проверяет, был ли открыт маршрут `/next`.  

### Пример 2: Тестирование формы ввода и валидации  
```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter/material.dart';

void main() {
  testWidgets('Тест валидации формы', (WidgetTester tester) async {
    await tester.pumpWidget(MaterialApp(
      home: Scaffold(
        body: Column(
          children: [
            TextField(
              validator: (value) {
                if (value == null || value.isEmpty) return 'Поле обязательно';
                return null;
              },
            ),
            ElevatedButton(
              onPressed: () {},
              child: Text('Отправить'),
            ),
          ],
        ),
      ),
    ));

    // Нажатие на кнопку отправки
    await tester.tap(find.text('Отправить'));
    await tester.pumpAndSettle();

    // Проверка, отображается ли сообщение об ошибке
    expect(find.text('Поле обязательно'), findsOneWidget);
  });
}
```
**Комментарии**:  
- `validator` в `TextField` проверяет корректность ввода.  
- После нажатия кнопки тест проверяет, отображается ли сообщение об ошибке.  

### Использование моков для сервисов  
Для имитации внешних зависимостей (например, API) используется пакет `mockito`. Пример:  
```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:http/http.dart' as http;
import 'package:mockito/mock.dart';
import 'dart:convert';

class MockClient extends Mock implements http.Client {}

void main() {
  final mockClient = MockClient();
  when(mockClient.get(Uri.parse('https://api.example.com/data')))
      .thenAnswer((_) async => http.Response(jsonEncode({'data': 'test'}), 200));

  testWidgets('Тест загрузки данных из API', (WidgetTester tester) async {
    await tester.pumpWidget(MaterialApp(
      home: Scaffold(
        body: FutureBuilder(
          future: http.get(Uri.parse('https://api.example.com/data'), client: mockClient),
          builder: (context, snapshot) {
            if (snapshot.hasData) return Text(snapshot.data!.body);
            return Text('Загрузка...');
          },
        ),
      ),
    ));

    await tester.pumpAndSettle();
    expect(find.text('test'), findsOneWidget);
  });
}
```
**Комментарии**:  
- `MockClient` имитирует HTTP-запросы.  
- `when(...).thenAnswer(...)` задаёт возвращаемое значение для мока.  

---

## Запуск интеграционных тестов  

### Команды Flutter для запуска тестов  
1. **Запуск всех интеграционных тестов**:  
```bash
flutter test test/integration
```
2. **Запуск конкретного теста**:  
```bash
flutter test test/integration/login_screen_test.dart
```
3. **При запуске на устройстве или эмуляторе** (необходимо добавить флаг `--device-id`):  
```bash
flutter test --device-id=<id_устройства> test/integration
```

### Настройка окружения для тестирования  
- Убедитесь, что в `test/integration` есть файл `integration_test.dart`. Этот файл содержит глобальные настройки и может использоваться для регистрации моков или загрузки конфигурации.  
- Для работы с реальными API во время тестирования используйте флаги:  
```bash
--use-test-fonts --dart-define=FLUTTER_WEB_USE_SKIA=true
```

### Обработка ошибок и улучшение производительности  
- **Используйте `pumpAndSettle()`**: Она позволяет дождаться завершения всех асинхронных операций (например, загрузки данных с сервера).  
- **Логирование**: Добавьте `print` или `debugPrint` в тесты для отладки.  
- **Используйте моки вместо реальных API**: Это ускоряет выполнение тестов и упрощает их запуск.  

---

## Практическое задание  
### Задача: Тестирование процесса авторизации пользователя  
**Требования**:  
1. Реализуйте в приложении экран входа с полями логина и пароля, кнопкой "Войти" и отображением ошибок (например, "Неверный логин или пароль").  
2. Напишите интеграционный тест, который:  
   - Проверяет, что при вводе пустого логина и нажатии на кнопку "Войти" отображается сообщение об ошибке.  
   - При успешном входе (правильные данные) пользователь переходит на следующий экран.  

**Подсказки**:  
- Используйте `TextField` с валидатором для проверки пустых полей.  
- Для моков API используйте `mockito`, чтобы имитировать успешную авторизацию.  

---

## Контрольные вопросы по теме  
1. **Чем отличаются интеграционные тесты от юнит-тестов в Flutter?**  
   - Интеграционные тесты проверяют взаимодействие компонентов, а юнит-тесты — отдельные функции или методы.  

2. **Какие библиотеки используются для написания интеграционных тестов в Flutter?**  
   - `flutter_test` и его подмодуль `integration_test`.  

3. **Каким образом можно имитировать внешние зависимости (например, API) во время тестирования?**  
   - Используя моки через пакет `mockito`.  

4. **Какие команды Flutter используются для запуска интеграционных тестов?**  
   - `flutter test test/integration` и `flutter test <путь_к_файлу>`.  

5. **Как проверить, что приложение корректно обрабатывает ошибки сети в интеграционном тесте?**  
   - Используйте моки для имитации ответа сервера с кодом 500 и проверяйте отображение сообщений об ошибке.  

---

## Список литературы и ссылки  
1. **Официальная документация Flutter**: [https://docs.flutter.dev/testing/integration-tests](https://docs.flutter.dev/testing/integration-tests)  
2. **Книга: "Flutter in Action" (Second Edition)** — содержит главы о тестировании и мокировании.  
3. **Статья на Medium: "Testing Flutter Apps with Integration Tests"** — [https://medium.com/@mohamed_abdelhameed/testing-flutter-apps-with-integration-tests-6b5d8a4f7e0c](https://medium.com/@mohamed_abdelhameed/testing-flutter-apps-with-integration-tests-6b5d8a4f7e0c)  
4. **Пакет `mockito` (для моков)**: [https://pub.dev/packages/mockito](https://pub.dev/packages/mockito)  
5. **Примеры тестов на GitHub**: [https://github.com/flutter/flutter/tree/master/dev/integration_tests](https://github.com/flutter/flutter/tree/master/dev/integration_tests)  

---

## Дополнительные советы и лучшие практики  
- **Используйте `find.byKey` вместо `find.text`**: Это делает тесты более устойчивыми к изменениям UI.  
- **Тестируйте только ключевые пользовательские сценарии**, а не все возможные комбинации (например, не проверяйте каждый путь в приложении).  
- **Используйте `setUp` и `tearDown`**: Для подготовки и очистки тестовой среды.  
- **Фокусируйтесь на UI-тестах**, а логику бизнеса проверяйте юнит-тестами.  

Следуя этим рекомендациям, вы сможете создавать надёжные и эффективные интеграционные тесты для ваших Flutter-приложений!