<think>
Okay, I need to create a detailed lecture on software design patterns for a Flutter developer at the Junior level. The user specified four patterns: Singleton, Mediator, Strategy, and Facade, each with their own sections. They also want practical exercises, control questions, and references. Let's start by breaking down each pattern.

First, **Singleton**. I should explain what it is, its pros and cons in Flutter, and how to implement it using Kiwi. The main problem with Singleton is that it can cause issues with testing and maintainability. But in Dart, the standard approach isn't as straightforward as in other languages, so Kiwi (a dependency injection library) might be a better fit. I need to provide an example of a singleton without Kiwi first, then show how Kiwi does it.

Next, **Mediator** pattern. The Mediator helps reduce coupling between classes by having them communicate through a mediator object. In Flutter, this could be useful for managing interactions between widgets, like a state management approach similar to BLoC but more lightweight. An example using the Mediator pattern with Dart would involve creating a mediator class that handles communication between different components.

**Strategy** pattern is about encapsulating algorithms and making them interchangeable. For Flutter, this might apply in scenarios where you have multiple ways to perform an action, like different payment methods or sorting algorithms. I'll need to create an example where the strategy changes dynamically, maybe using a dropdown selection that triggers different strategies.

Finally, **Facade** pattern simplifies complex subsystems by providing a unified interface. In Flutter, this could be useful when dealing with multiple APIs or libraries that have complicated setups. For instance, wrapping Firebase's setup into a single facade class to make it easier to use throughout the app.

Each section needs detailed explanations and code examples in Dart/Flutter with comments. Then, the practical task should involve implementing these patterns in a sample Flutter project, like an app where each pattern is used in different parts (e.g., Singleton for a database, Mediator for event handling, Strategy for payment methods, Facade for API calls). Control questions will test understanding of each pattern's purpose and application. References should include books, online resources, and the Kiwi library documentation.

Wait, I should check if there are other dependency injection tools in Flutter besides Kiwi, but since the user specified Kiwi, stick with that. Also, ensure that the examples are simple enough for a junior developer to follow. Avoid using too complex libraries or concepts beyond what's necessary. Make sure the code is well-commented and explains each part of the implementation.

For the Mediator example, maybe use a scenario where multiple widgets need to communicate without directly referencing each other. The mediator could be a provider or a state management solution, but since it's about the pattern itself, keep it simple with a class that holds callbacks.

In the Strategy example, perhaps create different sorting strategies for a list of items, allowing users to select which strategy to apply dynamically.

For Facade, maybe combine multiple services into a single interface. For instance, integrating Firebase Authentication and Firestore through a facade class that handles both in one place.

Also, ensure that each pattern's possible problems are discussed. Singleton can lead to tight coupling and issues with testing; Mediator might complicate the code if overused; Strategy requires careful management of strategy classes; Facade could hide too much complexity from developers if not designed well.

Need to structure the lecture logically: start with an introduction, then each pattern with its own section, followed by practical tasks, control questions, and references. Make sure the language is clear, avoiding jargon where possible, but still technical enough for a junior developer.
</think>

# Лекция 01. Паттерны проектирования в Flutter и Dart  
## **Тема: Singleton, Mediator, Strategy, Facade**  

---

### **Введение: Что такое паттерны проектирования?**  
Паттерны проектирования — это обобщённые решения для часто встречающихся проблем в программировании. Они помогают создавать чистый, легко поддерживаемый и масштабируемый код. В Flutter и Dart паттерны особенно полезны из-за сложности управления состоянием, зависимостями и взаимодействием между компонентами.  

В этой лекции мы рассмотрим четыре популярных паттерна:  
1. **Singleton** — обеспечение единой точки доступа к объекту.  
2. **Mediator** — уменьшение прямых зависимостей между классами через центральный посредник.  
3. **Strategy** — динамическое изменение поведения объектов.  
4. **Facade** — упрощение взаимодействия с сложными подсистемами.  

---

## **1. Singleton: Единственный экземпляр класса**

### **Что такое Singleton?**
Singleton — это паттерн, который гарантирует создание только одного экземпляра класса в приложении. Это полезно для объектов, которые должны быть глобально доступны (например, сервисы, хранилища данных, менеджеры состояния).

### **Преимущества Singleton**
- Упрощает доступ к общим ресурсам (например, конфигурации приложения).  
- Позволяет избежать повторного создания объектов.  

### **Проблемы Singleton в Flutter**:
1. **Тестирование**: Трудно заменять реализацию объекта в тестах (нарушает принцип единственной ответственности).  
2. **Глобальное состояние**: Может привести к сложным зависимостям и трудностям с отладкой.  
3. **Разделение модулей**: Использование глобальных объектов затрудняет изоляцию компонентов.

### **Реализация Singleton в Dart без библиотек**
```dart
class DatabaseService {
  static final DatabaseService _instance = DatabaseService._internal();

  factory DatabaseService() => _instance;

  DatabaseService._internal();
}
```

**Пример использования:**
```dart
void main() {
  var db1 = DatabaseService(); // Всегда будет ссылаться на один и тот же объект
  var db2 = DatabaseService();
  print(db1 == db2); // true
}
```

### **Реализация Singleton с помощью Kiwi (Dependency Injection)**
Kiwi — это популярная библиотека для инъекции зависимостей в Flutter. Она позволяет использовать Singleton через `registerSingleton`.

**Шаг 1: Добавьте зависимости**
```yaml
dependencies:
  kiwi: ^3.0.0
```

**Шаг 2: Используйте Kiwi для регистрации Singleton**
```dart
import 'package:kiwi/kiwi.dart';

class AuthService {
  void login(String email, String password) {
    print("Пользователь $email успешно аутентифицирован");
  }
}

void main() {
  KiwiContainer container = KiwiContainer();

  // Регистрация Singleton
  container.registerSingleton<AuthService>(AuthService());

  runApp(MyApp());
}
```

**Пример использования в виджете:**
```dart
class MyApp extends StatelessWidget {
  final AuthService authService;

  MyApp({required this.authService});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: Center(
          child: ElevatedButton(
            onPressed: () => authService.login("user@example.com", "password"),
            child: Text("Login"),
          ),
        ),
      ),
    );
  }
}
```

---

## **2. Mediator: Управляющий класс для координации взаимодействия**

### **Что такое Mediator?**
Медиатор — это объект, который устраняет прямые зависимости между компонентами. Вместо того чтобы виджеты напрямую вызывать друг друга, они отправляют сообщения через медиатор.

**Пример в Flutter**:  
Если у вас есть несколько виджетов, которые должны обновляться при изменении состояния (например, кнопка и текст), Mediator может служить центральным хабом для этих действий.

### **Реализация Mediator**
```dart
// Медиатор для передачи сообщений между компонентами
class EventMediator {
  final List<EventListener> _listeners = [];

  void registerListener(EventListener listener) {
    _listeners.add(listener);
  }

  void notify(String eventName, [dynamic data]) {
    for (var listener in _listeners) {
      listener.onEvent(eventName, data);
    }
  }
}

// Интерфейс для слушателей
abstract class EventListener {
  void onEvent(String eventName, dynamic data);
}
```

**Пример использования в Flutter:**
```dart
class CounterWidget extends StatefulWidget {
  @override
  _CounterWidgetState createState() => _CounterWidgetState();
}

class _CounterWidgetState extends State<CounterWidget> with SingleTickerProviderStateMixin {
  int count = 0;

  @override
  void initState() {
    super.initState();
    EventMediator().registerListener(this);
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text("Счетчик: $count"),
        ElevatedButton(
          onPressed: () {
            EventMediator().notify("increment");
          },
          child: Text("Увеличить"),
        ),
      ],
    );
  }

  void onEvent(String eventName, dynamic data) {
    if (eventName == "increment") {
      setState(() => count++);
    }
  }
}
```

---

## **3. Strategy: Динамическое изменение поведения**

### **Что такое Strategy?**
Паттерн Strategy позволяет менять алгоритмы или поведение объекта во время выполнения. Это полезно, когда у вас есть несколько вариантов реализации одного и того же действия (например, сортировка данных, выбор способа оплаты).

### **Пример в Flutter: Выбор метода сортировки**
```dart
// Интерфейс стратегии
abstract class SortStrategy {
  List<int> sort(List<int> numbers);
}

// Конкретная реализация (сортировка по возрастанию)
class AscendingSort implements SortStrategy {
  @override
  List<int> sort(List<int> numbers) {
    return [...numbers]..sort();
  }
}

// Конкретная реализация (сортировка по убыванию)
class DescendingSort implements SortStrategy {
  @override
  List<int> sort(List<int> numbers) {
    return [...numbers]..sort((a, b) => b.compareTo(a));
  }
}

// Контекст, который использует стратегию
class NumberSorter {
  late SortStrategy _strategy;

  void setStrategy(SortStrategy strategy) {
    _strategy = strategy;
  }

  List<int> sort(List<int> numbers) {
    return _strategy.sort(numbers);
  }
}
```

**Пример использования в Flutter:**
```dart
void main() {
  runApp(MaterialApp(
    home: Scaffold(
      appBar: AppBar(title: Text("Strategy Pattern")),
      body: Center(
        child: Column(
          children: [
            ElevatedButton(
              onPressed: () {
                var sorter = NumberSorter();
                sorter.setStrategy(AscendingSort());
                print(sorter.sort([3, 1, 4])); // [1, 3, 4]
              },
              child: Text("Сортировать по возрастанию"),
            ),
            ElevatedButton(
              onPressed: () {
                var sorter = NumberSorter();
                sorter.setStrategy(DescendingSort());
                print(sorter.sort([3, 1, 4])); // [4, 3, 1]
              },
              child: Text("Сортировать по убыванию"),
            ),
          ],
        ),
      ),
    ),
  ));
}
```

---

## **4. Facade: Упрощение сложных подсистем**

### **Что такое Facade?**
Facade — это обёртка, которая предоставляет простой интерфейс для взаимодействия со сложной подсистемой. Это полезно при интеграции нескольких библиотек или API (например, Firebase).

### **Пример в Flutter: Фасад для работы с Firebase**
```dart
// Обёртка для Firebase Auth и Firestore
class FirebaseFacade {
  final FirebaseAuth auth = FirebaseAuth.instance;
  final FirebaseFirestore firestore = FirebaseFirestore.instance;

  // Регистрация пользователя
  Future<void> registerUser(String email, String password) async {
    await auth.createUserWithEmailAndPassword(email: email, password: password);
  }

  // Сохранение данных в Firestore
  Future<void> saveUserData(String userId, Map<String, dynamic> data) async {
    await firestore.collection("users").doc(userId).set(data);
  }
}
```

**Пример использования в Flutter:**
```dart
class RegistrationScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Column(
          children: [
            ElevatedButton(
              onPressed: () async {
                final facade = FirebaseFacade();
                await facade.registerUser("user@example.com", "password123");
              },
              child: Text("Зарегистрироваться"),
            ),
          ],
        ),
      ),
    );
  }
}
```

---

## **Практическое задание**  
Создайте Flutter-приложение с использованием всех четырёх паттернов. Условия:  
1. **Singleton**: Реализуйте глобальный сервис для хранения настроек пользователя (например, язык интерфейса).  
2. **Mediator**: Создайте систему уведомлений между виджетами (например, кнопка вызывает изменение текста в другом месте экрана).  
3. **Strategy**: Реализуйте выбор способа оплаты (например, банковские карты или электронные кошельки).  
4. **Facade**: Оберните взаимодействие с API (например, получение данных о продуктах и их отображение).  

---

## **Контрольные вопросы**  
1. Какой паттерн используется для создания единственного экземпляра класса? Опишите его проблемы в Flutter.  
2. В чём отличие Mediator от централизованного управления состоянием (например, Provider)?  
3. Приведите пример использования Strategy в Flutter. Почему он полезен?  
4. Как Facade упрощает интеграцию с внешними API?  

---

## **Список литературы и ссылки**  
1. **Оригинальные паттерны проектирования**: [Design Patterns: Elements of Reusable Object-Oriented Software](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612) (Эрик Гамма и др.).  
2. **Dart и Flutter**: Официальная документация [Dart.dev](https://dart.dev), [Flutter.dev](https://flutter.dev).  
3. **Kiwi** — библиотека для инъекции зависимостей: [kiwi.readthedocs.io](https://kiwi.readthedocs.io/).  
4. **Книга "Clean Architecture"**: Роберт Мартин (на английском).  
5. **Статья о паттерне Mediator в Flutter**: [medium.com/flutter/flutter-state-management-patterns-2023](https://medium.com/flutter/flutter-state-management-patterns-2023).  

---

## **Заключение**  
Понимание паттернов проектирования — ключ к созданию масштабируемых и поддерживаемых приложений. Практика с Singleton, Mediator, Strategy и Facade поможет вам избежать общих ошибок в архитектуре Flutter-приложений. Продолжайте изучать эти паттерны, экспериментируйте с их реализациями, и не бойтесь задавать вопросы!