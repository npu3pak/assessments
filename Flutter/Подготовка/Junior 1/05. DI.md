# Лекция 05: Инъекция зависимостей (DI) в мобильном разработке на Flutter (Dart)

## Введение
Инъекция зависимостей — это ключевой принцип современного программирования, особенно важный при создании масштабируемых и легко тестируемых приложений. В этой лекции мы подробно разберёмся с тем, что такое DI, как он работает в Flutter, а также изучим инструменты и техники его реализации.

---

## 1. Описание принципов DI

**Что такое инъекция зависимостей?**

DI (Dependency Injection) — это паттерн проектирования, который позволяет управлять связями между объектами в приложении. Вместо того, чтобы классы сами создавали свои зависимости, они получают их извне. Это обеспечивает:

- **Разделение ответственности**: Класс не заботится о создании объектов, которые он использует.
- **Упрощение тестирования**: Можно легко подменять реальные зависимости на моки (mocks) при написании юнит-тестов.
- **Гибкость и масштабируемость**: Упрощает замену реализации зависимостей без изменения кода.

### Основные принципы DI

1. **Инверсия управления (IoC)**  
   Вместо того, чтобы объект сам создавал свои зависимости (например, `DatabaseService db = DatabaseService()`), они внедряются извне (например, `MyClass(this.db)`).

2. **Разделение абстракций от реализаций**  
   Классы работают с интерфейсами (абстрактными типами), а не с конкретной реализацией. Это позволяет легко менять поведение приложения без изменения кода.

3. **Синглтоны и фабрики**  
   DI-контейнеры могут управлять жизненным циклом объектов: создавать одиночные экземпляры (синглтоны) или производить новые инстансы по мере необходимости.

---

## 2. Способы внедрения зависимостей

### 2.1. Конструктор
Наиболее популярный способ в Flutter и Dart — передача зависимостей через конструктор класса.

**Пример:**

```dart
class UserRepository {
  final UserDataSource dataSource;

  // Зависимость (UserDataSource) внедрена через конструктор
  UserRepository(this.dataSource);
}

class UserDataSource {
  Future<List<User>> fetchUsers() async {
    return await _fetchFromAPI(); // Реализация загрузки данных
  }
}
```

**Преимущества:**
- Прозрачность — зависимости явно указаны в конструкторе.
- Упрощает тестирование: можно передать мок-реализацию `UserDataSource`.

### 2.2. Методы и свойства
Можно внедрять зависимости через методы (например, `setDataSource()`) или свойства.

**Пример:**

```dart
class UserRepository {
  UserDataSource? dataSource;

  void setDataSource(UserDataSource newDataSource) {
    dataSource = newDataSource;
  }

  Future<List<User>> getUsers() async {
    if (dataSource == null) {
      throw Exception("Драйвер не установлен");
    }
    return await dataSource!.fetchUsers();
  }
}
```

**Когда использовать:**
- Когда зависимости могут изменяться динамически.
- В сложных архитектурах, где объекты создаются и настраивались поэтапно.

---

## 3. Локатор сервисов (Dependency Locators)

Локатор — это глобальный контейнер, который хранит и предоставляет зависимости по запросу. В Flutter часто используются библиотеки типа **Provider**, **GetIt** или **Kiwi**.

### Пример с Provider

```dart
// main.dart
void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        Provider<UserRepository>(create: (_) => UserRepository(UserDataSource())),
      ],
      child: MaterialApp(
        home: HomePage(),
      ),
    );
  }
}
```

**Преимущества локаторов:**
- Упрощают доступ к зависимостям из любых мест приложения.
- Подходят для крупных проектов с множеством сервисов.

### Проблемы и ограничения

1. **Сложность тестирования**  
   Если зависимости зарегистрированы глобально, их сложно переопределить в тестах без изменений кода.

2. **Связь между компонентами**  
   Локатор может создать "скрытые" связи между классами, что затрудняет понимание архитектуры приложения.

3. **Трудности с отладкой**  
   Если локатор не настроен правильно (например, зарегистрированы несколько экземпляров одного сервиса), это может привести к ошибкам в работе приложения.

---

## 4. Возможности и ограничения библиотеки **Kiwi**

**Kiwi** — легковесная реализация DI-контейнера для Dart, которая поддерживает:

### Возможности:
- Регистрация зависимостей (factory, singleton).
- Поддержка параметризации.
- Использование типов и интерфейсов.

**Пример:**

```dart
import 'package:kiwi/kiwi.dart';

class UserDataSource {
  Future<List<User>> fetchUsers() async => [User(id: 1)];
}

class UserRepository {
  final UserDataSource dataSource;

  UserRepository(this.dataSource);
}

void main() {
  // Регистрация зависимостей
  KiwiContainer container = KiwiContainer();
  container.registerFactory<UserDataSource>(() => UserDataSource());
  container.registerFactory<UserRepository>(() => UserRepository(container.get<UserDataSource>()));

  // Получение экземпляра
  var userRepo = container.get<UserRepository>();
}
```

### Ограничения:
- **Сложность конфигурации**  
   Для крупных проектов может потребоваться много кода на регистрацию зависимостей.
- **Нет встроенной поддержки асинхронных операций** (нужно самому обрабатывать).
- **Не оптимизирована для Flutter** — рекомендуется использовать более специфические библиотеки, такие как Provider или GetIt.

---

## 5. Циклические зависимости и способы их решения

### Что такое циклическая зависимость?

Циклическая зависимость возникает, когда два или больше объектов зависят друг от друга напрямую или через промежуточные классы.

**Пример:**
```dart
class A {
  B b;
  A(this.b);
}

class B {
  A a;
  B(this.a);
}
```

При создании объекта `A` требуется `B`, а для создания `B` нужно `A`. Это приведёт к ошибке: `StateError: Recursive call`.

---

### Способы решения

#### 1. **Рефакторинг кода**
Измените структуру классов так, чтобы они не зависели друг от друга напрямую.

**Пример:**

```dart
class Service {
  void doSomething() {
    // Общий функционал
  }
}

class A {
  final Service service;
  A(this.service);
}

class B {
  final Service service;
  B(this.service);
}
```

Теперь `A` и `B` зависят только от общего сервиса, а не друг от друга.

#### 2. **Использование интерфейсов**
Разделите абстракции от реализаций. Это позволяет избежать прямой зависимости между классами.

**Пример:**

```dart
abstract class DependencyA {
  void method();
}

class A implements DependencyA {
  final B b;
  A(this.b);
  @override
  void method() {}
}

abstract class DependencyB {
  void anotherMethod();
}

class B implements DependencyB {
  final DependencyA a;
  B(this.a);
  @override
  void anotherMethod() {}
}
```

#### 3. **Lazy initialization**
Используйте отложенную инициализацию (lazy init) в Dart, чтобы избежать циклического вызова конструкторов.

**Пример:**

```dart
class A {
  late B b;
}

class B {
  final A a;
  B(this.a);
}
```

Однако это может привести к ошибкам, если объекты будут использоваться до инициализации. Лучше использовать DI-контейнеры с поддержкой lazy init.

---

## Практическое задание

**Цель:** Научиться внедрять зависимости в Flutter-приложение с использованием Provider.

### Задача:
Создайте приложение, которое использует инъекцию зависимостей. В нём должны быть:

1. Модель данных: `User` (имя, возраст).
2. Сервис для работы с данными: `UserService`, который зависит от `DataRepository`.
3. Репозиторий: `DataRepository`, который загружает пользователей из локального источника.
4. Используйте **Provider** для внедрения зависимостей.

### Шаги:

1. Создайте проект Flutter.
2. Определите классы `User`, `UserService`, `DataRepository`.
3. Реализуйте `DataRepository` с методом `loadUsers()` (возвращающим список пользователей).
4. Внедрите `DataRepository` в `UserService` через конструктор.
5. Используйте `Provider` для предоставления экземпляров классов.
6. Проверьте работу приложения, используя тесты (моки).

---

## Контрольные вопросы

1. Что такое инъекция зависимостей? Приведите пример.
2. Какие типы внедрения зависимостей вы знаете?
3. В чём разница между синглтоном и фабрикой в контексте DI?
4. Что такое локатор сервисов, и как он влияет на архитектуру приложения?
5. Какие преимущества у библиотеки Kiwi?
6. Как решить циклическую зависимость между классами A и B?

---

## Список литературы и ссылки

1. **Официальный документ Flutter** — [https://flutter.dev/docs](https://flutter.dev/docs)
2. **Книга: "Flutter Apprentice" by Ray Wenderlich** — подробный учебник по архитектуре приложений.
3. **Библиотека Provider на GitHub** — [https://pub.dev/packages/provider](https://pub.dev/packages/provider)
4. **Библиотека Kiwi для Dart** — [https://pub.dev/packages/kiwi](https://pub.dev/packages/kiwi)
5. **Статья: "Dependency Injection in Flutter" (FlutterDev Blog)** — [https://medium.com/flutter-community/dependency-injection-in-flutter-14d6f9a2e38e](https://medium.com/flutter-community/dependency-injection-in-flutter-14d6f9a2e38e)
6. **Советы по архитектуре приложений** (Clean Architecture, BLoC, Redux) — [https://flutter.dev/docs/development/architecture](https://flutter.dev/docs/development/architecture)

---

## Заключение

Инъекция зависимостей — это не просто технический трюк, а важный инструмент для создания чистого и поддерживаемого кода. Умение правильно внедрять зависимости, избегать циклических связей и использовать DI-инструменты поможет вам стать профессиональным разработчиком Flutter. Регулярная практика с использованием библиотек Provider, GetIt или Kiwi поможет улучшить понимание архитектурных паттернов и повысить качество вашего кода.