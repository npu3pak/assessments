# Лекция: Наследование в Dart  
## Тема: Основы наследования классов и модификаторы в Dart  

---

### 1. **Основные принципы наследования классов**  
Наследование — это фундаментальный механизм объектно-ориентированного программирования (ООП), позволяющий создавать новые классы, повторно используя код существующих классов. В Dart наследование реализуется через ключевое слово `extends`.  

#### Основные концепции:  
1. **Родительский класс** — базовый класс, от которого наследуются другие классы (например, `Animal`).  
2. **Дочерний класс** (или подкласс) — класс, который расширяет функциональность родительского класса (`Dog`, `Cat`).  
3. **Инкапсуляция** — возможность скрывать внутреннюю реализацию и предоставлять только интерфейс для взаимодействия с объектом.  

#### Пример:  
```dart  
// Родительский класс  
class Animal {  
  String name;  

  Animal(this.name);  

  void eat() {  
    print("$name ест");  
  }  
}  

// Дочерний класс  
class Dog extends Animal {  
  Dog(String name) : super(name);  

  void bark() {  
    print("$name лает");  
  }  
}  

void main() {  
  Dog myDog = Dog("Бобик");  
  myDog.eat(); // Вызов метода родительского класса  
  myDog.bark(); // Вызов метода дочернего класса  
}  
```  

#### Особенности наследования в Dart:  
- **Переопределение методов**: Методы дочернего класса могут переопределять методы родительского класса с использованием ключевого слова `@override`.  
  ```dart  
  class Dog extends Animal {  
    @override  
    void eat() {  
      super.eat(); // Вызов оригинального метода  
      print("Псина $name ест кость");  
    }  
  }  
  ```  
- **Вызов родительских конструкторов**: Используется `super()` для передачи аргументов в конструкторы родительского класса.  
- **Скрытые поля**: В Dart нет явной возможности скрывать поля, но можно использовать модификаторы доступа (`private`, `protected`), как это описано ниже.  

---

### 2. **Модификатор base**  
В Dart **нет прямого эквивалента** ключевого слова `base`, используемого в некоторых языках (например, C#). Вместо этого:  
- **Базовый класс** указывается через `extends`. Например, если вы хотите создать класс, который расширяет другой класс, вы пишете:  
  ```dart  
  class Derived extends Base { ... }  
  ```  
- Если нужно ограничить наследование (например, сделать класс базовым для всех подклассов), используется `sealed` (см. ниже).  

**Важно**: В Dart **не существует понятия "базовый класс" как отдельного модификатора**, но концепция базового класса реализуется через наследование (`extends`).  

---

### 3. **Модификаторы abstract, interface и abstract interface**  
В Dart **интерфейсы и абстрактные классы** используются как основа для определения интерфейсов (наборов методов), которые должны быть реализованы в других классах.  

#### **Абстрактный класс (`abstract`)**:  
- Абстрактный класс не может создавать экземпляров, но может содержать абстрактные методы (методы без реализации) и конкретные методы.  
  ```dart  
  abstract class Shape {  
    void draw(); // Абстрактный метод  
    String toString() => "Это форма"; // Конкретный метод  
  }  

  class Circle extends Shape {  
    @override  
    void draw() {  
      print("Рисуем окружность");  
    }  
  }  
  ```  

#### **Интерфейсы (`interface`)**:  
- В Dart интерфейс реализуется через абстрактные классы. Класс может реализовать интерфейс, определяя все его методы.  
  ```dart  
  abstract class Drawable {  
    void draw();  
  }  

  class Square implements Drawable {  
    @override  
    void draw() => print("Рисуем квадрат");  
  }  
  ```  

#### **Абстрактный интерфейс (`abstract interface`)**:  
- Это не стандартное понятие в Dart. Однако можно создать абстрактный класс, который содержит только абстрактные методы (то есть является "интерфейсом" в терминах других языков).  

**Пример**:  
```dart  
abstract class Animal {  
  void move(); // Абстрактный интерфейс  
}  

class Dog implements Animal {  
  @override  
  void move() => print("Пёс бегает");  
}  
```  

---

### 4. **Модификатор final**  
Ключевое слово `final` используется для объявления переменных, значения которых **не могут быть изменены после инициализации**. Это особенно полезно для определения **константных значений**, но также может применяться в контексте наследования.  

#### Примеры:  
```dart  
class Person {  
  final String name; // Поле может быть инициализировано только один раз  
  int age;  

  Person(this.name);  

  void setName(String newName) => name = newName; // Ошибка! `name` нельзя изменить.  
}  
```  

#### Использование в наследовании:  
- Если поле объявлено как `final`, оно может быть переопределено в подклассах, но **только при инициализации**.  
  ```dart  
  class Base {  
    final String title = "Базовый класс";  
  }  

  class Derived extends Base {  
    // Переназначение невозможно  
    // final String title = "Деривированный класс"; // Ошибка!  
  }  
  ```  

**Примечание**: В Flutter `final` часто используется для определения неизменяемых состояний, например, в модели данных:  
```dart  
class User {  
  final String name;  
  final int age;  

  User(this.name, this.age);  
}  
```  

---

### 5. **Модификатор sealed**  
Ключевое слово `sealed` ограничивает наследование класса, разрешая создание подклассов **только в том же файле**, где объявлен базовый класс. Это помогает управлять иерархией классов с ограниченным количеством возможных подклассов.  

#### Пример:  
```dart  
sealed class Animal {  
  // Абстрактный метод  
  void makeSound();  
}  

// Только в этом файле можно создавать подклассы  
class Dog extends Animal {  
  @override  
  void makeSound() => print("Гав!");  
}  

class Cat extends Animal {  
  @override  
  void makeSound() => print("Мяу!");  
}  
```  

#### Преимущества:  
- Упрощает проверку исчерпывающих условий (например, `switch` в Dart).  
  ```dart  
  void animalSound(Animal animal) {  
    switch (animal) {  
      case Dog():  
        print("Это собака");  
        break;  
      case Cat():  
        print("Это кошка");  
        break;  
      default:  
        // Невозможно, т.к. sealed ограничивает возможные подклассы  
    }  
  }  
  ```  

---

### 6. **Extensions**  
Ключевое слово `extension` позволяет добавлять методы и свойства к существующим типам без изменения их исходного кода. Это особенно полезно при расширении функциональности стандартных библиотек или классов из сторонних пакетов.  

#### Пример:  
```dart  
extension StringExtensions on String {  
  bool containsIgnoreCase(String other) =>  
      this.toLowerCase().contains(other.toLowerCase());  
}  

void main() {  
  print("Hello".containsIgnoreCase("HELLO")); // true  
}  
```  

#### Использование в Flutter:  
- Расширение `BuildContext` для упрощения работы с виджетами.  
  ```dart  
  extension ContextExtensions on BuildContext {  
    void showSnackbar(String message) {  
      ScaffoldMessenger.of(this).showSnackBar(SnackBar(content: Text(message)));  
    }  
  }  

  // В Widget:  
  context.showSnackbar("Успешно!");  
  ```  

---

## Практическое задание  
Создайте приложение Flutter, реализующее следующие функции:  
1. **Иерархия классов**:  
   - Основной класс `Shape` с абстрактным методом `draw()`.  
   - Подклассы `Circle`, `Square`, `Triangle`, реализующие метод `draw()`.  
2. Используйте `sealed class` для определения базового класса `Animal`, от которого наследуются `Dog`, `Cat`.  
3. Добавьте `final`-поля в классы и проверьте их неизменяемость.  
4. Создайте `extension` для добавления метода `capitalize()` к строкам.  

**Пример кода**:  
```dart  
sealed class Animal {  
  void makeSound();  
}  

class Dog extends Animal {  
  @override  
  void makeSound() => print("Гав!");  
}  

abstract class Shape {  
  void draw();  
}  

class Circle implements Shape {  
  @override  
  void draw() => print("Окружность нарисована");  
}  

extension StringExtension on String {  
  String capitalize() => this[0].toUpperCase() + substring(1);  
}  
```  

---

## Контрольные вопросы  
1. Какие ключевые слова используются для наследования классов в Dart? Приведите примеры.  
2. Чем отличаются абстрактный класс и интерфейс в Dart?  
3. Что такое `sealed`-класс, и какова его польза при проектировании архитектуры приложения?  
4. Как использовать модификатор `final`, и почему он полезен для состояния в Flutter?  
5. Какие преимущества дает использование `extension` в Dart? Приведите пример из Flutter.  

---

## Список литературы и ссылки для дополнительного чтения  
1. [Официальная документация Dart: Наследование](https://dart.dev/guides/language/objects)  
2. [Flutter и ООП: Примеры наследования в Flutter приложениях](https://flutter.dev/docs/development/data-and-backend/state-mgmt/basics)  
3. [Абстрактные классы и интерфейсы в Dart](https://dart.dev/guides/language/objects#abtract-classes)  
4. [Sealed classes in Dart: Продвинутый подход к типам](https://www.dartlang.org/guides/language/working-with-classes#sealed-classes)  
5. [Extensions: Расширение функциональности в Dart](https://dart.dev/guides/language/extension-methods)  
6. Книга "Dart in Action" — подробное руководство по языкам Dart и Flutter.  
7. YouTube-канал **Flutter Dev** — видеоуроки по использованию наследования в Flutter.  

--- 

Эта лекция охватывает все аспекты наследования, модификаторы, абстрактные классы и расширения в Dart. Она предназначена для самостоятельного изучения и углубленного понимания темы.