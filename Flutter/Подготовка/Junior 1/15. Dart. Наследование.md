<think>
Хорошо, я получил задание подготовить подробную лекцию по наследованию в Dart для мобильного разработчика на уровне Junior. Нужно охватить все пункты из списка вопросов: основы наследования классов, модификатор base, abstract, interface, abstract interface, final, sealed и extensions. Также добавить практическое задание, контрольные вопросы и список литературы. 

Сначала я должен вспомнить, какие базовые принципы наследования существуют в Dart. Наследование позволяет создавать новые классы на основе существующих, что помогает повторно использовать код и улучшать структуру программы. В Dart используются ключевые слова как extends для наследования от одного класса, implements для реализации интерфейсов, а также abstract для абстрактных классов.

Модификатор base — это нестандартный термин в Dart. Возможно, имеется в виду базовый класс или что-то подобное. Нужно уточнить. В Dart нет строго определенного модификатора base, но обычно подразумевают базовые классы, от которых наследуются другие. Может быть, речь идет о ключевом слове super для вызова конструктора родительского класса.

Модификаторы abstract, interface и abstract interface — в Dart интерфейсы реализуются через абстрактные классы. Абстрактный класс может содержать абстрактные методы (без реализации) и конкретные. Ключевое слово abstract используется для объявления абстрактных классов или методов. Интерфейсы в Dart не являются отдельным типом, а представляют собой набор абстрактных методов, которые могут быть реализованы в других классах.

Модификатор final — он применяется к переменным и полям класса, чтобы они могли быть инициализированы только один раз. В контексте наследования final может использоваться для определения неизменяемых полей, которые могут переопределяться в подклассах при необходимости.

Модификатор sealed — ограничивает наследование класса, позволяя создавать подклассы только внутри того же файле. Это помогает в проектировании иерархий классов с ограниченным количеством возможных подклассов.

Extensions — это способ добавления методов или свойств к существующему типу без изменения его исходного кода. В Dart это делается через ключевое слово extension, что может быть полезно для расширения функциональности библиотек.

Теперь нужно структурировать лекцию по этим пунктам, добавив подробные примеры на Dart и Flutter. Например, для наследования можно привести пример с классом Animal и его подклассами Dog и Cat. Для abstract — создание абстрактного класса Shape с абстрактным методом draw(). Sealed класс может быть использован в перечислении типов данных.

Важно проверить, нет ли ошибок в понимании модификатора base. Возможно, это опечатка или относится к другому языку программирования. В Dart такого модификатора нет, поэтому стоит упомянуть, что в Dart базовый класс указывается через extends, а для ограничения наследования используется sealed.

Практическое задание должно позволить применить все изученные концепции: создать иерархию классов с использованием abstract, sealed, final, и extensions. Контрольные вопросы помогут закрепить материал, а литература — даст возможность углубиться в тему.

Нужно убедиться, что все примеры корректны и соответствуют синтаксису Dart 2.x, так как это актуальная версия для Flutter. Также важно подробно описать каждую часть лекции, чтобы она была понятна даже новичкам.
</think>

# Лекция: Наследование в Dart  
## Тема: Основы наследования классов и модификаторы в Dart  

---

### 1. **Основные принципы наследования классов**  
Наследование — это фундаментальный механизм объектно-ориентированного программирования (ООП), позволяющий создавать новые классы, повторно используя код существующих классов. В Dart наследование реализуется через ключевое слово `extends`.  

#### Основные концепции:  
1. **Родительский класс** — базовый класс, от которого наследуются другие классы (например, `Animal`).  
2. **Дочерний класс** (или подкласс) — класс, который расширяет функциональность родительского класса (`Dog`, `Cat`).  
3. **Инкапсуляция** — возможность скрывать внутреннюю реализацию и предоставлять только интерфейс для взаимодействия с объектом.  

#### Пример:  
```dart  
// Родительский класс  
class Animal {  
  String name;  

  Animal(this.name);  

  void eat() {  
    print("$name ест");  
  }  
}  

// Дочерний класс  
class Dog extends Animal {  
  Dog(String name) : super(name);  

  void bark() {  
    print("$name лает");  
  }  
}  

void main() {  
  Dog myDog = Dog("Бобик");  
  myDog.eat(); // Вызов метода родительского класса  
  myDog.bark(); // Вызов метода дочернего класса  
}  
```  

#### Особенности наследования в Dart:  
- **Переопределение методов**: Методы дочернего класса могут переопределять методы родительского класса с использованием ключевого слова `@override`.  
  ```dart  
  class Dog extends Animal {  
    @override  
    void eat() {  
      super.eat(); // Вызов оригинального метода  
      print("Псина $name ест кость");  
    }  
  }  
  ```  
- **Вызов родительских конструкторов**: Используется `super()` для передачи аргументов в конструкторы родительского класса.  
- **Скрытые поля**: В Dart нет явной возможности скрывать поля, но можно использовать модификаторы доступа (`private`, `protected`), как это описано ниже.  

---

### 2. **Модификатор base**  
В Dart **нет прямого эквивалента** ключевого слова `base`, используемого в некоторых языках (например, C#). Вместо этого:  
- **Базовый класс** указывается через `extends`. Например, если вы хотите создать класс, который расширяет другой класс, вы пишете:  
  ```dart  
  class Derived extends Base { ... }  
  ```  
- Если нужно ограничить наследование (например, сделать класс базовым для всех подклассов), используется `sealed` (см. ниже).  

**Важно**: В Dart **не существует понятия "базовый класс" как отдельного модификатора**, но концепция базового класса реализуется через наследование (`extends`).  

---

### 3. **Модификаторы abstract, interface и abstract interface**  
В Dart **интерфейсы и абстрактные классы** используются как основа для определения интерфейсов (наборов методов), которые должны быть реализованы в других классах.  

#### **Абстрактный класс (`abstract`)**:  
- Абстрактный класс не может создавать экземпляров, но может содержать абстрактные методы (методы без реализации) и конкретные методы.  
  ```dart  
  abstract class Shape {  
    void draw(); // Абстрактный метод  
    String toString() => "Это форма"; // Конкретный метод  
  }  

  class Circle extends Shape {  
    @override  
    void draw() {  
      print("Рисуем окружность");  
    }  
  }  
  ```  

#### **Интерфейсы (`interface`)**:  
- В Dart интерфейс реализуется через абстрактные классы. Класс может реализовать интерфейс, определяя все его методы.  
  ```dart  
  abstract class Drawable {  
    void draw();  
  }  

  class Square implements Drawable {  
    @override  
    void draw() => print("Рисуем квадрат");  
  }  
  ```  

#### **Абстрактный интерфейс (`abstract interface`)**:  
- Это не стандартное понятие в Dart. Однако можно создать абстрактный класс, который содержит только абстрактные методы (то есть является "интерфейсом" в терминах других языков).  

**Пример**:  
```dart  
abstract class Animal {  
  void move(); // Абстрактный интерфейс  
}  

class Dog implements Animal {  
  @override  
  void move() => print("Пёс бегает");  
}  
```  

---

### 4. **Модификатор final**  
Ключевое слово `final` используется для объявления переменных, значения которых **не могут быть изменены после инициализации**. Это особенно полезно для определения **константных значений**, но также может применяться в контексте наследования.  

#### Примеры:  
```dart  
class Person {  
  final String name; // Поле может быть инициализировано только один раз  
  int age;  

  Person(this.name);  

  void setName(String newName) => name = newName; // Ошибка! `name` нельзя изменить.  
}  
```  

#### Использование в наследовании:  
- Если поле объявлено как `final`, оно может быть переопределено в подклассах, но **только при инициализации**.  
  ```dart  
  class Base {  
    final String title = "Базовый класс";  
  }  

  class Derived extends Base {  
    // Переназначение невозможно  
    // final String title = "Деривированный класс"; // Ошибка!  
  }  
  ```  

**Примечание**: В Flutter `final` часто используется для определения неизменяемых состояний, например, в модели данных:  
```dart  
class User {  
  final String name;  
  final int age;  

  User(this.name, this.age);  
}  
```  

---

### 5. **Модификатор sealed**  
Ключевое слово `sealed` ограничивает наследование класса, разрешая создание подклассов **только в том же файле**, где объявлен базовый класс. Это помогает управлять иерархией классов с ограниченным количеством возможных подклассов.  

#### Пример:  
```dart  
sealed class Animal {  
  // Абстрактный метод  
  void makeSound();  
}  

// Только в этом файле можно создавать подклассы  
class Dog extends Animal {  
  @override  
  void makeSound() => print("Гав!");  
}  

class Cat extends Animal {  
  @override  
  void makeSound() => print("Мяу!");  
}  
```  

#### Преимущества:  
- Упрощает проверку исчерпывающих условий (например, `switch` в Dart).  
  ```dart  
  void animalSound(Animal animal) {  
    switch (animal) {  
      case Dog():  
        print("Это собака");  
        break;  
      case Cat():  
        print("Это кошка");  
        break;  
      default:  
        // Невозможно, т.к. sealed ограничивает возможные подклассы  
    }  
  }  
  ```  

---

### 6. **Extensions**  
Ключевое слово `extension` позволяет добавлять методы и свойства к существующим типам без изменения их исходного кода. Это особенно полезно при расширении функциональности стандартных библиотек или классов из сторонних пакетов.  

#### Пример:  
```dart  
extension StringExtensions on String {  
  bool containsIgnoreCase(String other) =>  
      this.toLowerCase().contains(other.toLowerCase());  
}  

void main() {  
  print("Hello".containsIgnoreCase("HELLO")); // true  
}  
```  

#### Использование в Flutter:  
- Расширение `BuildContext` для упрощения работы с виджетами.  
  ```dart  
  extension ContextExtensions on BuildContext {  
    void showSnackbar(String message) {  
      ScaffoldMessenger.of(this).showSnackBar(SnackBar(content: Text(message)));  
    }  
  }  

  // В Widget:  
  context.showSnackbar("Успешно!");  
  ```  

---

## Практическое задание  
Создайте приложение Flutter, реализующее следующие функции:  
1. **Иерархия классов**:  
   - Основной класс `Shape` с абстрактным методом `draw()`.  
   - Подклассы `Circle`, `Square`, `Triangle`, реализующие метод `draw()`.  
2. Используйте `sealed class` для определения базового класса `Animal`, от которого наследуются `Dog`, `Cat`.  
3. Добавьте `final`-поля в классы и проверьте их неизменяемость.  
4. Создайте `extension` для добавления метода `capitalize()` к строкам.  

**Пример кода**:  
```dart  
sealed class Animal {  
  void makeSound();  
}  

class Dog extends Animal {  
  @override  
  void makeSound() => print("Гав!");  
}  

abstract class Shape {  
  void draw();  
}  

class Circle implements Shape {  
  @override  
  void draw() => print("Окружность нарисована");  
}  

extension StringExtension on String {  
  String capitalize() => this[0].toUpperCase() + substring(1);  
}  
```  

---

## Контрольные вопросы  
1. Какие ключевые слова используются для наследования классов в Dart? Приведите примеры.  
2. Чем отличаются абстрактный класс и интерфейс в Dart?  
3. Что такое `sealed`-класс, и какова его польза при проектировании архитектуры приложения?  
4. Как использовать модификатор `final`, и почему он полезен для состояния в Flutter?  
5. Какие преимущества дает использование `extension` в Dart? Приведите пример из Flutter.  

---

## Список литературы и ссылки для дополнительного чтения  
1. [Официальная документация Dart: Наследование](https://dart.dev/guides/language/objects)  
2. [Flutter и ООП: Примеры наследования в Flutter приложениях](https://flutter.dev/docs/development/data-and-backend/state-mgmt/basics)  
3. [Абстрактные классы и интерфейсы в Dart](https://dart.dev/guides/language/objects#abtract-classes)  
4. [Sealed classes in Dart: Продвинутый подход к типам](https://www.dartlang.org/guides/language/working-with-classes#sealed-classes)  
5. [Extensions: Расширение функциональности в Dart](https://dart.dev/guides/language/extension-methods)  
6. Книга "Dart in Action" — подробное руководство по языкам Dart и Flutter.  
7. YouTube-канал **Flutter Dev** — видеоуроки по использованию наследования в Flutter.  

--- 

Эта лекция охватывает все аспекты наследования, модификаторы, абстрактные классы и расширения в Dart. Она предназначена для самостоятельного изучения и углубленного понимания темы.