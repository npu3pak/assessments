### Лекция: Основы iOS-разработки на Swift  
**Тема:** Разбор ключевых концепций Swift для разработчика уровня Middle 3  

---

## **1. Отличия `class` и `struct` в Swift**

В Swift `class` и `struct` — это два основных способа определения типов данных, но они имеют принципиальные различия по поведению и использованию.

### **Основные отличия:**
| Характеристика | `class` | `struct` |
|----------------|---------|----------|
| **Семантика** | Ссылочный тип (reference type) | Значениеный тип (value type) |
| **Наследование** | Поддерживает наследование, протоколы, виртуальные методы | Не поддерживает наследование |
| **Модификация данных** | Изменения объекта влияют на все ссылки на него | Изменение структуры создает новую копию |
| **Сравнение** | Сравнивается по ссылке (== проверяет идентичность) | Сравнивается по значению (== проверяет равенство данных) |
| **Использование в коллекциях** | Может храниться в массивах, словарях, но не изменяться без копирования | Хранится как значение, при модификации создается новая копия |

### **Пример:**
```swift
class Person {
    var name = "John"
}

struct Employee {
    var name = "Jane"
}

var person1 = Person()
var person2 = person1  // person2 ссылается на тот же объект в памяти
person2.name = "Alice"  // Изменение влияет и на person1
print(person1.name)     // Выведет: Alice

var employee1 = Employee()
var employee2 = employee1  // employee2 — копия employee1
employee2.name = "Bob"
print(employee1.name)    // Выведет: Jane (изменение в employee2 не влияет на employee1)
```

### **Когда использовать `class` vs `struct`:**
- Используйте `struct`, если данные могут быть изменены независимо (например, модель данных).
- Используйте `class`, если требуется наследование или необходимо передать объект по ссылке.

---

## **2. Nullable-типы и проверка на null**

Swift не поддерживает явное значение `null` как в Java/PHP, но вместо этого использует **опциональные типы** (`Optional<T>`), которые представляют собой энам с двумя состояниями: `.some(T)` или `.none`.

### **Синтаксис опционалов:**
- Объявление опциональной переменной: `var name: String?`
- Проверка на наличие значения:
  - `if let` — безопасное разворачивание (unwrapping).
  - `guard let` — для раннего выхода из функции.
  - `optional chaining` (`?.`) — безопасный доступ к свойствам/методам.
  - `nil-coalescing operator` (`??`) — значение по умолчанию, если опционал пуст.

### **Пример:**
```swift
var optionalName: String? = nil

if let name = optionalName {
    print("Имя: $name)") // Выполняется только если optionalName != nil
} else {
    print("Имя не задано")
}

guard let safeName = optionalName else {
    print("Недопустимое имя") 
    return
}
print("Безопасное имя: $safeName)")

// Optional chaining
let length = optionalName?.count ?? 0 // Если optionalName == nil, вернёт 0

```

### **Рекомендации:**
- Избегайте использования `!` (forced unwrapping) без уверенности в наличии значения.
- Используйте опциональные типы только там, где значение может отсутствовать (например, данные из API).

---

## **3. Конструкции `guard` и `if let`**

Эти конструкции позволяют безопасно разворачивать опционалы и выявлять ошибки на ранних этапах.

### **`if let`:**
Используется для временного создания копии значения внутри блока, если опционал не пуст.
```swift
func greet(user: String?) {
    if let name = user {
        print("Привет, $name)")
    } else {
        print("Неизвестный пользователь")
    }
}
```

### **`guard`:**
Используется для выхода из функции/метода, если условие не выполнено. Полезно для очистки кода от вложенных `if let`.
```swift
func processUser(user: String?) {
    guard let name = user else {
        print("Недопустимое имя")
        return
    }
    print("Обработка пользователя: $name)")
}
```

### **Преимущества `guard`:**
- Улучшает читаемость кода.
- Позволяет избегать вложенности (nested if/let).
- Часто используется для проверки входных данных или условий внутри функций.

---

## **4. Сильные и слабые ссылки**

В Swift используются **ссылочные типы** (`class`), которые управляются **ARC (Automatic Reference Counting)**. ARC отслеживает количество ссылок на объект и уничтожает его, когда все ссылки удалены.

### **Проблема: Сильные циклы ссылок**
Если два объекта ссылаются друг на друга, это может вызвать утечку памяти:
```swift
class A {
    weak var b: B?
}

class B {
    strong var a = A()
}
```

### **Решение: `weak` и `unowned`**
- `weak`: Ссылка не увеличивает счётчик. Используется, если объект может быть уничтожен (например, делегаты).
- `unowned`: Ссылка не увеличивает счётчик. Используется только когда объект гарантированно существует (например, в closure-ах).

### **Пример:**
```swift
class View {
    weak var delegate: Delegate? // Удалится, если View уничтожена
}

class Delegate {
    func handleEvent() {}
}
```

---

## **5. Замыкания (Closures)**

Замыкания — это функции, которые можно передавать как аргументы или возвращать из других функций.

### **Основные концепции:**
- **Синтаксис замыкания:** `{ (параметры) -> Тип -> код }`
- **Захват переменных**: Замыкание может захватывать значения из окружающей области видимости.
- **Эскейп-замыкания**: Замыкания, которые могут быть сохранены и вызваны позже (например, в `Timer` или `URLSession`).
- **Capture List**: Управление ссылками на объекты внутри замыканий.

### **Пример:**
```swift
var closure: () -> Void = {
    print("Замыкание")
}

func executeClosure(closure: () -> Void) {
    closure()
}

executeClosure(closure: closure)
```

### **Capture List для избежания утечек памяти:**
```swift
class MyClass {
    var value = 0
    func makeClosure() -> () -> Void {
        return { [weak self] in
            self?.value += 1 // Использование weak self
            print("Value: $self?.value ?? 0)")
        }
    }
}
```

---

## **Практическое задание**

**Задача:** Реализуйте класс `User`, который:
1. Хранит имя и возраст.
2. Использует опциональные типы для хранения необязательных данных (например, `email`).
3. Включает метод `printDetails()`, который проверяет наличие email через `guard let`.
4. Создайте структуру `UserStorage`, которая сохраняет список пользователей и использует `weak` ссылки для избежания циклов.
5. Реализуйте замыкание, которое обновляет возраст пользователя и захватывает его безопасно.

---

## **Контрольные вопросы**

1. Что такое отличие между `class` и `struct` в Swift? Приведите пример.
2. Как проверить наличие значения в опционале с использованием `if let` и `guard let`?
3. Когда использовать `weak` ссылки, а когда `strong`? Приведите пример цикла ссылок и как его избежать.
4. Что такое замыкания? Какие типы замыканий существуют в Swift?
5. Какой синтаксис используется для захвата переменных в замыкании?

---

## **Список литературы и ссылок**

1. [Swift Programming Language (Apple)](https://developer.apple.com/swift/) — официальная документация.
2. [Ray Wenderlich: Swift Tutorials](https://www.raywenderlich.com/ios-tutorials) — практика с примерами кода.
3. **Книга:** "Swift in Practice" — Кристина Тернер, 2018 год (для углубленного понимания).
4. [Hacking with Swift](https://www.hackingwithswift.com/) — учебные материалы с проектами.
5. **Stack Overflow** — поиск вопросов по теме (например: "Swift closure capture list", "guard let vs if let").
6. [YouTube-канал: iOS Dev Tips](https://www.youtube.com/c/iOSDevTips) — видеоуроки по Swift и разработке.

---

## **Заключение**

Эта лекция охватывает ключевые концепции Swift, которые необходимы для создания стабильных приложений на iOS. Умение различать `class` и `struct`, безопасно работать с опционалами, избегать утечек памяти и использовать замыкания — основа профессиональной разработки. Практика через задание и контрольные вопросы поможет закрепить материал. Для углубления знаний рекомендуется изучить официальные источники и примеры из литературы.