# Лекция 12: iOS. Устранение утечек памяти  

## Введение  
Утечки памяти — один из самых коварных источников проблем в мобильном приложении. Они могут привести к нестабильной работе, увеличению потребления ресурсов и даже к сбою приложения. На iOS-платформе управление памятью осуществляется автоматически через **ARC (Automatic Reference Counting)**, но разработчик может ошибиться в использовании ссылок, что приведет к утечкам. В этой лекции мы подробно разберем:  
1. Как создать утечку памяти на Swift.  
2. Как использовать **Instruments** для поиска утечек.  
3. Как анализировать объекты с помощью инструмента **Memory Graph**.  

---

## 1. Как сделать утечку памяти в iOS?  

### Что такое утечка памяти?  
Утечка памяти происходит, когда объект не освобождается из-за неправильного управления ссылками на него, даже если он больше не нужен. Это чаще всего связано с **retain cycle** (циклом удержания), где два или более объектов держат друг друга в памяти, несмотря на отсутствие необходимости.  

### Пример 1: Утечка через замыкание  
```swift
class MyClass {
    var closure: () -> Void = { }
}

class LeakExample {
    let myClass = MyClass()
    
    init() {
        // Неправильное использование self в замыкании
        myClass.closure = { [weak self] in
            print("Замыкание работает, но не удерживает self")
        }
        
        // Утечка через сильную ссылку на self
        myClass.closure = {
            self.someMethod() // Здесь self держится в памяти из-за strong
        }
    }
    
    func someMethod() {
        print("Метод вызван")
    }
}
```

**Объяснение:**  
- В первом случае замыкание использует `[weak self]`, что позволяет избежать удержания `self`.  
- Во втором случае замыкание не использует `weak` или `unowned`, поэтому `LeakExample` сохраняется в памяти, даже если объект больше не нужен.  

---

### Пример 2: Цикл retain между двумя классами  
```swift
class A {
    weak var b: B?
}

class B {
    weak var a: A?
    
    init() {
        // Создание цикла удержания
        let a = A()
        let b = B()
        a.b = b
        b.a = a
    }
}
```

**Объяснение:**  
- Объекты `A` и `B` держат друг друга через **strong** ссылки. Это приведет к утечке, так как ни один из объектов не может быть освобожден (их счетчики ссылок никогда не достигнут нуля).  

---

## 2. Поиск утечек памяти с помощью Instruments  

### Что такое Instruments?  
**Instruments** — это инструмент для профилирования приложений на iOS, который позволяет анализировать производительность, использование памяти, CPU и другие метрики. Для поиска утечек используется **Leaks** и **Allocations**.  

---

### Шаг 1: Настройка проекта  
- Убедитесь, что в Xcode включен **Enable Test Flight**, если вы хотите запускать приложение на реальном устройстве.  
- В меню **Product → Profile** или нажмите `Cmd+I`.  

---

### Шаг 2: Использование инструмента "Leaks"  
1. В окне Instruments выберите **Leaks** (или **Allocations**, если вы хотите отслеживать все выделения памяти).  
2. Запустите приложение и воспроизведите действия, которые могут вызвать утечку.  
3. Если в графе появятся красные точки (уведомления об утечке), значит, были обнаружены объекты, которые не освобождаются.  

**Пример:**  
- При использовании кода из примера 2, Instruments покажет, что объекты `A` и `B` сохраняются в памяти даже после завершения работы.  

---

### Шаг 3: Анализ результата с помощью Allocations  
1. Переключитесь на **Allocations** (в меню выберите **Allocations**).  
2. Используйте фильтр по типу объекта (например, `A`, `B`).  
3. Найдите узел, который не уменьшается при завершении работы.  

---

### Пример: Детализация утечки  
Если вы запустите код из примера 1 в **Instruments**, то видно, что объект `LeakExample` сохраняется в памяти даже после его удаления, так как замыкание держит ссылку на него.  

---

## 3. Анализ ссылок на объекты с помощью Memory Graph  

### Что такое Memory Graph?  
**Memory Graph** — это инструмент в Xcode, который позволяет визуализировать связи между объектами в памяти. Он помогает находить циклы retain и ненужные ссылки.  

---

### Шаги для использования:  
1. В Xcode откройте **Debug Navigator** (или используйте `Cmd+Shift+Y`).  
2. Нажмите на значок **Memory Graph Debugger** (глядя на иконку с объектами).  
3. Выберите **Start** и выполните действия в приложении, которые могут вызвать утечку.  

---

### Пример: Определение цикла retain  
- Если вы запустите код из примера 2, Memory Graph покажет связь между `A` и `B`, где оба объекта держат друг друга через strong ссылки.  
- Это явно указано как **retain cycle** в графе.  

---

### Как исправить:  
- В классах `A` или `B` замените **strong** на **weak** для одного из свойств (например, `weak var b: B?`).  
- Это разорвет цикл и позволит ARC освободить объекты.  

---

## Практическое задание  

### Задача: Исправьте утечку в коде  
1. Создайте два класса `ClassA` и `ClassB`, которые держат друг друга через strong ссылки (как в примере 2).  
2. Добавьте замыкание в одном из классов, которое ссылается на `self` без использования `[weak self]`.  
3. Запустите приложение и проверьте утечку с помощью **Instruments** и **Memory Graph Debugger**.  
4. Исправьте код, чтобы устранить циклы retain и неправильное использование замыканий.  

### Пример шаблона кода:  
```swift
class ClassA {
    var classB: ClassB?
    
    init() {
        let b = ClassB()
        self.classB = b
        b.a = self
    }
}

class ClassB {
    var a: ClassA
    
    init() {
        self.a = ClassA()
    }
}
```

---

## Контрольные вопросы  
1. Что такое retain cycle и как он возникает?  
2. Какие инструменты Xcode используются для поиска утечек памяти?  
3. Чем отличаются `weak` и `unowned` ссылки в Swift?  
4. Как работает **ARC** при наличии замыканий, которые держат объекты?  
5. Приведите пример кода с утечкой через замыкание и объясните, почему это происходит.  

---

## Список литературы и дополнительные материалы  
1. **Официальная документация Apple: Memory Management Guide for Swift**  
   - [https://developer.apple.com/library/archive/documentation/Swift/Conceptual/SwiftProgrammingLanguage/AutomaticReferenceCounting.html](https://developer.apple.com/library/archive/documentation/Swift/Conceptual/SwiftProgrammingLanguage/AutomaticReferenceCounting.html)  

2. **Book: "Advanced Swift" by Paul Hudson**  
   - Глава 15: Memory Management and ARC  

3. **Сторонние ресурсы:**  
   - [https://www.raywenderlich.com/790-swift-memory-management](https://www.raywenderlich.com/790-swift-memory-management) — подробное руководство по управлению памятью в Swift.  

4. **Instruments и Memory Graph Debugger:**  
   - [https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/XcodeDebugging/](https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/XcodeDebugging/) — официальное руководство по использованию Xcode для отладки.  

5. **Статья на Medium: "Understanding Retain Cycles in Swift"**  
   - [https://medium.com/@sakshamagarwal02/understanding-retain-cycles-in-swift-8c1e4a799f8d](https://medium.com/@sakshamagarwal02/understanding-retain-cycles-in-swift-8c1e4a799f8d)  

---

## Заключение  
Утечки памяти — это серьезная проблема, но с правильными инструментами и пониманием работы ARC их можно избежать. Использование **Instruments** и **Memory Graph Debugger**, а также умение работать с `weak`, `unowned` ссылками и замыканиями — ключевые навыки для разработчика Middle уровня. Практика на примерах, описанных выше, поможет вам уверенно диагностировать и устранять проблемы в своих проектах.