<think>
Okay, I need to create a detailed lecture on Dart closures and nested functions for an intern-level Flutter developer. Let me start by outlining the structure based on the user's request.

First, the main topics are closures, nested functions, and using typedef for closure types. Each needs a thorough explanation with examples in Dart and Flutter. The user wants this to be self-contained, so I need to ensure that all concepts are explained from the ground up without assuming prior knowledge beyond basic Dart/Flutter skills.

Starting with closures. I should define what a closure is—essentially a function that captures variables from its surrounding scope. Need examples where functions capture variables from outer scopes. Maybe show how closures can retain state even after the outer function has exited. Use simple Dart examples first, then maybe a Flutter example showing how this might be used in a widget's context.

Next, nested functions. Explain that these are functions defined inside another function. Discuss scope and accessibility—nested functions can access variables from the enclosing function but not vice versa. Provide an example where a nested function modifies a variable declared in the outer function. Also, mention any limitations or best practices here.

Then, typedef for closure types. This is about creating type aliases for function types to make code more readable. Show how typedefs can be used to define the signature of closures and how this improves readability and maintainability. Include an example where a typedef is used in a Flutter widget's callback.

For each section, I need detailed text with explanations and comments in the code examples. The practical assignment should involve creating a Flutter app that uses these concepts—maybe a simple counter using nested functions and closures, and a typedef for a button press handler.

Control questions will test understanding of key points: definitions, differences between nested functions and closures, how typedefs improve code structure, etc. References should include official Dart documentation and relevant Flutter resources.

I need to make sure the language is clear and accessible for an intern. Avoid overly technical jargon where possible, but still be precise. Use step-by-step explanations in examples. Check that all parts of the user's request are addressed: detailed lecture, practical task, control questions, references. Also, ensure that examples use Dart and Flutter appropriately, maybe with StatefulWidgets or StatelessWidget for Flutter parts.

Wait, the user mentioned that the practical assignment should be a Flutter app. Let me think of a simple example where closures and nested functions are used. Perhaps a StatefulWidget that uses a closure in its state to update UI elements, and a typedef for handling button clicks.

Also, need to cover how closures are different from regular functions—capture variables, retain access even after the outer function has completed. Nested functions can't be passed around as first-class citizens like closures can? Or wait, in Dart, nested functions can be returned or assigned to variables if they're declared with a return type and name, but maybe that's more advanced. Need to clarify.

In the typedef section, show how using typedefs can make code clearer when dealing with callbacks. For example, replacing Function() with a custom typedef like ButtonHandler.

I should also mention use cases: closures in asynchronous operations (like Future or Stream callbacks), nested functions for encapsulating logic within another function's scope.

Make sure all examples are well-commented and explain each part. Maybe include a Flutter example where a closure is used to track state changes, and a typedef is applied to an event handler.

Now, structure the lecture with clear headings for each topic, then practical assignment, control questions, references. Keep paragraphs concise but informative. Avoid repetition. Ensure that after reading this, the intern can confidently apply these concepts in their projects.
</think>

# Лекция 19: Dart. Замыкания и вложенные функции  

## Введение  
Замыкания (closures) и вложенные функции — важные концепции в программировании на языке Dart, особенно при разработке мобильных приложений с Flutter. Они позволяют создавать гибкие и модульные решения, упрощают управление состоянием и обработку событий. В этой лекции мы подробно рассмотрим:  
1. **Замыкания** — функции, которые "запоминают" окружение, в котором были созданы.  
2. **Вложенные функции** — функции, определённые внутри другой функции.  
3. **Использование `typedef` для типизации замыканий**, что улучшает читаемость кода и позволяет использовать более понятные названия типов функций.  

---

## 1. Замыкания (Closures) в Dart  

### Определение  
Замыкание — это **функция, которая сохраняет доступ к переменным из окружения**, в котором она была создана, даже после того, как её внешняя функция завершилась. Это позволяет замыканию "запоминать" состояние и изменять его в будущем.  

### Как работают замыкания  
Замыкание создаётся, когда:  
- Функция определена внутри другой функции (вложенная функция).  
- Эта вложенная функция использует переменные из внешней области видимости.  
- Замыкание может быть передано в другую часть программы или сохранено в переменной для дальнейшего использования.  

### Пример: Замыкание с сохранением состояния  
```dart
void main() {
  // Внешняя функция, которая создаёт замыкание
  void outerFunction() {
    int count = 0; // Переменная из внешней области видимости

    // Вложенная функция (замыкание)
    Function incrementCounter() {
      count++; // Использует переменную из внешней области
      print("Счётчик: $count");
    }

    return incrementCounter;
  }

  final closure = outerFunction(); // Получаем замыкание
  closure(); // Вывод: Счётчик: 1
  closure(); // Вывод: Счётчик: 2
}
```  

**Объяснение:**  
- `incrementCounter` — это замыкание, которое сохраняет ссылку на переменную `count`, даже после завершения `outerFunction`.  
- При каждом вызове `closure()` значение `count` увеличивается и выводится. Это демонстрирует, как замыкания могут "запоминать" состояние из внешней области видимости.  

### Пример в Flutter: Замыкание для отслеживания состояния  
```dart
import 'package:flutter/material.dart';

class CounterWidget extends StatefulWidget {
  @override
  _CounterWidgetState createState() => _CounterWidgetState();
}

class _CounterWidgetState extends State<CounterWidget> {
  int _count = 0;

  // Замыкание для обновления счётчика
  void createClosure() {
    int count = 0;
    VoidCallback increment = () {
      setState(() {
        count++;
        _count = count; // Обновляем состояние виджета через замыкание
      });
    };
    increment();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text("Счётчик: $_count"),
        ElevatedButton(onPressed: createClosure, child: Text("Увеличить")),
      ],
    );
  }
}
```  

**Объяснение:**  
- В этом примере замыкание `increment` использует переменную `count`, которая определена в методе `createClosure`.  
- При нажатии кнопки вызывается `increment()`, который увеличивает `count` и обновляет состояние виджета через `setState()`.  
- Это показывает, как замыкания могут использоваться для хранения промежуточных данных, не зависящих от состояния виджета.  

---

## 2. Вложенные функции (Nested Functions) в Dart  

### Определение  
Вложенная функция — это функция, которая определена внутри другой функции. Она может использовать переменные из внешней области видимости и вызываться только внутри той же области.  

### Характеристики вложенных функций:  
- **Доступ к переменным из внешней области:** Вложенная функция может читать и изменять переменные из родительской функции.  
- **Не могут быть переданы в другую часть программы:** В отличие от замыканий, вложенные функции не могут быть сохранены в переменной или переданы как параметр.  
- **Используются для локальной логики:** Подходят для выполнения задач внутри конкретной функции.  

### Пример: Вложенная функция для обработки данных  
```dart
void main() {
  void processNumbers(List<int> numbers) {
    int sum = 0;

    // Вложенная функция: суммирует числа из списка
    void addNumbers() {
      for (var num in numbers) {
        sum += num;
      }
    }

    addNumbers(); // Вызов вложенной функции
    print("Сумма: $sum");
  }

  processNumbers([1, 2, 3]); // Вывод: Сумма: 6
}
```  

**Объяснение:**  
- `addNumbers` — это вложенная функция внутри `processNumbers`. Она использует переменную `sum`, объявленную во внешней функции.  
- При вызове `addNumbers()` суммируются числа из списка `numbers`, и результат сохраняется в `sum`.  

### Пример в Flutter: Вложенная функция для фильтрации данных  
```dart
class FilteredList extends StatefulWidget {
  @override
  _FilteredListState createState() => _FilteredListState();
}

class _FilteredListState extends State<FilteredList> {
  List<String> items = ['Apple', 'Banana', 'Cherry', 'Date'];

  void filterItems(String query) {
    // Вложенная функция: фильтрует элементы по запросу
    void filter() {
      setState(() {
        items = items.where((item) => item.contains(query)).toList();
      });
    }

    filter(); // Вызов вложенной функции
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        TextField(
          onChanged: (value) => filterItems(value),
          decoration: InputDecoration(labelText: 'Поиск'),
        ),
        ListView.builder(
          itemCount: items.length,
          itemBuilder: (context, index) => ListTile(title: Text(items[index])),
        ),
      ],
    );
  }
}
```  

**Объяснение:**  
- Вложенная функция `filter()` используется для фильтрации списка элементов по введённому запросу.  
- Она изменяет состояние `items` через `setState()`, что приводит к обновлению UI.  

---

## 3. Использование `typedef` для описания типов замыканий  

### Определение  
`typedef` позволяет создавать **алиасы (псевдонимы)** для функциональных типов, упрощая код и делая его более понятным. Это особенно полезно при работе с замыканиями и коллбэками в Flutter.  

### Синтаксис:  
```dart
typedef ТипНазвания = ReturnType Function(Параметры);
```  

### Пример: Определение `typedef` для типа функции  
```dart
void main() {
  // Определение псевдонима для функции, возвращающей void и не принимающей аргументов
  typedef VoidCallback = void Function();

  // Использование typedef в замыкании
  VoidCallback callback = () => print("Вызвано через typedef");

  callback(); // Вывод: Вызвано через typedef
}
```  

**Объяснение:**  
- `VoidCallback` — это псевдоним для функции, которая не принимает аргументов и возвращает `void`. Это стандартный тип в Flutter, например, используется в кнопках (`onPressed`).  
- Использование `typedef` делает код более читаемым: вместо `Function()` можно использовать `VoidCallback`, что объясняет назначение функции.  

### Пример в Flutter: `typedef` для обработки событий  
```dart
import 'package:flutter/material.dart';

// Определение псевдонима для функции, обрабатывающей нажатие кнопки
typedef ButtonHandler = void Function(String value);

class TypedefExample extends StatelessWidget {
  final ButtonHandler onButtonPressed;

  const TypedefExample({Key? key, required this.onButtonPressed}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: () => onButtonPressed("Кнопка нажата"),
      child: Text("Нажми меня"),
    );
  }
}

void main() {
  runApp(MaterialApp(
    home: Scaffold(
      body: Center(
        child: TypedefExample(
          onButtonPressed: (value) => print(value),
        ),
      ),
    ),
  ));
}
```  

**Объяснение:**  
- `ButtonHandler` — псевдоним для функции, которая принимает строку и возвращает `void`.  
- В компоненте `TypedefExample` передаётся функция `onButtonPressed`, обрабатывающая нажатие кнопки. Это делает код более понятным: вместо `Function(String)` используется `ButtonHandler`, что описывает назначение функции.  

---

## Практическое задание  
**Задача:** Создайте приложение Flutter с двумя компонентами:  
1. **Кнопка**, которая увеличивает счётчик с использованием замыкания и вложенной функции.  
2. **Поле ввода**, которое фильтрует список элементов по запросу с помощью `typedef`.  

### Требования:  
- Используйте замыкание для хранения состояния счётчика (например, внутри метода).  
- Реализуйте вложенную функцию для обработки логики фильтрации.  
- Определите `typedef` для типизации коллбэка кнопки и поля ввода.  

### Пример ожидаемого поведения:  
- Нажатие на кнопку увеличивает счётчик, используя замыкание.  
- Ввод текста фильтрует список элементов (например, отображаются только элементы, содержащие введённый текст).  

---

## Контрольные вопросы по теме  
1. **Что такое замыкание? Приведите пример его использования в Dart.**  
2. **Как отличаются замыкания и вложенные функции? В чём их преимущества?**  
3. **Как `typedef` упрощает работу с типами функций в Flutter?**  
4. **Можно ли передать вложенную функцию как параметр другой функции? Почему?**  
5. **Как использовать замыкание для хранения состояния в Flutter-приложении?**  

---

## Список литературы и ссылки для дополнительного чтения  
1. [Официальная документация Dart: Functions](https://dart.dev/guides/language/functions)  
2. [Flutter documentation on callbacks and closures](https://flutter.dev/docs/development/ui/advanced-topics/closures)  
3. [Блог Flutter: Working with closures in StatefulWidgets](https://medium.com/flutter/working-with-closures-in-flutter-7d6c40a41d5f)  
4. **Книга:** "Dart in Action" — Дэвид Хардинг, Ник Бернс (разделы о замыканиях и функциональных типах).  
5. [Советы по использованию `typedef` в Flutter](https://medium.com/flutter/using-typedef-to-make-your-flutter-code-cleaner-9b2d378f4c0d)  

---

## Заключение  
Замыкания и вложенные функции — мощные инструменты для разработки гибких и масштабируемых приложений на Dart и Flutter. Использование `typedef` позволяет улучшить читаемость кода, особенно при работе с коллбэками. Практика решения задач, описанных в данном разделе, поможет закрепить понимание этих концепций и применять их эффективно в реальных проектах.