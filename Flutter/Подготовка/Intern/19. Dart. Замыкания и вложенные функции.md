# Лекция 19: Dart. Замыкания и вложенные функции  

## Введение  
Замыкания (closures) и вложенные функции — важные концепции в программировании на языке Dart, особенно при разработке мобильных приложений с Flutter. Они позволяют создавать гибкие и модульные решения, упрощают управление состоянием и обработку событий. В этой лекции мы подробно рассмотрим:  
1. **Замыкания** — функции, которые "запоминают" окружение, в котором были созданы.  
2. **Вложенные функции** — функции, определённые внутри другой функции.  
3. **Использование `typedef` для типизации замыканий**, что улучшает читаемость кода и позволяет использовать более понятные названия типов функций.  

---

## 1. Замыкания (Closures) в Dart  

### Определение  
Замыкание — это **функция, которая сохраняет доступ к переменным из окружения**, в котором она была создана, даже после того, как её внешняя функция завершилась. Это позволяет замыканию "запоминать" состояние и изменять его в будущем.  

### Как работают замыкания  
Замыкание создаётся, когда:  
- Функция определена внутри другой функции (вложенная функция).  
- Эта вложенная функция использует переменные из внешней области видимости.  
- Замыкание может быть передано в другую часть программы или сохранено в переменной для дальнейшего использования.  

### Пример: Замыкание с сохранением состояния  
```dart
void main() {
  // Внешняя функция, которая создаёт замыкание
  void outerFunction() {
    int count = 0; // Переменная из внешней области видимости

    // Вложенная функция (замыкание)
    Function incrementCounter() {
      count++; // Использует переменную из внешней области
      print("Счётчик: $count");
    }

    return incrementCounter;
  }

  final closure = outerFunction(); // Получаем замыкание
  closure(); // Вывод: Счётчик: 1
  closure(); // Вывод: Счётчик: 2
}
```  

**Объяснение:**  
- `incrementCounter` — это замыкание, которое сохраняет ссылку на переменную `count`, даже после завершения `outerFunction`.  
- При каждом вызове `closure()` значение `count` увеличивается и выводится. Это демонстрирует, как замыкания могут "запоминать" состояние из внешней области видимости.  

### Пример в Flutter: Замыкание для отслеживания состояния  
```dart
import 'package:flutter/material.dart';

class CounterWidget extends StatefulWidget {
  @override
  _CounterWidgetState createState() => _CounterWidgetState();
}

class _CounterWidgetState extends State<CounterWidget> {
  int _count = 0;

  // Замыкание для обновления счётчика
  void createClosure() {
    int count = 0;
    VoidCallback increment = () {
      setState(() {
        count++;
        _count = count; // Обновляем состояние виджета через замыкание
      });
    };
    increment();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text("Счётчик: $_count"),
        ElevatedButton(onPressed: createClosure, child: Text("Увеличить")),
      ],
    );
  }
}
```  

**Объяснение:**  
- В этом примере замыкание `increment` использует переменную `count`, которая определена в методе `createClosure`.  
- При нажатии кнопки вызывается `increment()`, который увеличивает `count` и обновляет состояние виджета через `setState()`.  
- Это показывает, как замыкания могут использоваться для хранения промежуточных данных, не зависящих от состояния виджета.  

---

## 2. Вложенные функции (Nested Functions) в Dart  

### Определение  
Вложенная функция — это функция, которая определена внутри другой функции. Она может использовать переменные из внешней области видимости и вызываться только внутри той же области.  

### Характеристики вложенных функций:  
- **Доступ к переменным из внешней области:** Вложенная функция может читать и изменять переменные из родительской функции.  
- **Не могут быть переданы в другую часть программы:** В отличие от замыканий, вложенные функции не могут быть сохранены в переменной или переданы как параметр.  
- **Используются для локальной логики:** Подходят для выполнения задач внутри конкретной функции.  

### Пример: Вложенная функция для обработки данных  
```dart
void main() {
  void processNumbers(List<int> numbers) {
    int sum = 0;

    // Вложенная функция: суммирует числа из списка
    void addNumbers() {
      for (var num in numbers) {
        sum += num;
      }
    }

    addNumbers(); // Вызов вложенной функции
    print("Сумма: $sum");
  }

  processNumbers([1, 2, 3]); // Вывод: Сумма: 6
}
```  

**Объяснение:**  
- `addNumbers` — это вложенная функция внутри `processNumbers`. Она использует переменную `sum`, объявленную во внешней функции.  
- При вызове `addNumbers()` суммируются числа из списка `numbers`, и результат сохраняется в `sum`.  

### Пример в Flutter: Вложенная функция для фильтрации данных  
```dart
class FilteredList extends StatefulWidget {
  @override
  _FilteredListState createState() => _FilteredListState();
}

class _FilteredListState extends State<FilteredList> {
  List<String> items = ['Apple', 'Banana', 'Cherry', 'Date'];

  void filterItems(String query) {
    // Вложенная функция: фильтрует элементы по запросу
    void filter() {
      setState(() {
        items = items.where((item) => item.contains(query)).toList();
      });
    }

    filter(); // Вызов вложенной функции
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        TextField(
          onChanged: (value) => filterItems(value),
          decoration: InputDecoration(labelText: 'Поиск'),
        ),
        ListView.builder(
          itemCount: items.length,
          itemBuilder: (context, index) => ListTile(title: Text(items[index])),
        ),
      ],
    );
  }
}
```  

**Объяснение:**  
- Вложенная функция `filter()` используется для фильтрации списка элементов по введённому запросу.  
- Она изменяет состояние `items` через `setState()`, что приводит к обновлению UI.  

---

## 3. Использование `typedef` для описания типов замыканий  

### Определение  
`typedef` позволяет создавать **алиасы (псевдонимы)** для функциональных типов, упрощая код и делая его более понятным. Это особенно полезно при работе с замыканиями и коллбэками в Flutter.  

### Синтаксис:  
```dart
typedef ТипНазвания = ReturnType Function(Параметры);
```  

### Пример: Определение `typedef` для типа функции  
```dart
void main() {
  // Определение псевдонима для функции, возвращающей void и не принимающей аргументов
  typedef VoidCallback = void Function();

  // Использование typedef в замыкании
  VoidCallback callback = () => print("Вызвано через typedef");

  callback(); // Вывод: Вызвано через typedef
}
```  

**Объяснение:**  
- `VoidCallback` — это псевдоним для функции, которая не принимает аргументов и возвращает `void`. Это стандартный тип в Flutter, например, используется в кнопках (`onPressed`).  
- Использование `typedef` делает код более читаемым: вместо `Function()` можно использовать `VoidCallback`, что объясняет назначение функции.  

### Пример в Flutter: `typedef` для обработки событий  
```dart
import 'package:flutter/material.dart';

// Определение псевдонима для функции, обрабатывающей нажатие кнопки
typedef ButtonHandler = void Function(String value);

class TypedefExample extends StatelessWidget {
  final ButtonHandler onButtonPressed;

  const TypedefExample({Key? key, required this.onButtonPressed}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: () => onButtonPressed("Кнопка нажата"),
      child: Text("Нажми меня"),
    );
  }
}

void main() {
  runApp(MaterialApp(
    home: Scaffold(
      body: Center(
        child: TypedefExample(
          onButtonPressed: (value) => print(value),
        ),
      ),
    ),
  ));
}
```  

**Объяснение:**  
- `ButtonHandler` — псевдоним для функции, которая принимает строку и возвращает `void`.  
- В компоненте `TypedefExample` передаётся функция `onButtonPressed`, обрабатывающая нажатие кнопки. Это делает код более понятным: вместо `Function(String)` используется `ButtonHandler`, что описывает назначение функции.  

---

## Практическое задание  
**Задача:** Создайте приложение Flutter с двумя компонентами:  
1. **Кнопка**, которая увеличивает счётчик с использованием замыкания и вложенной функции.  
2. **Поле ввода**, которое фильтрует список элементов по запросу с помощью `typedef`.  

### Требования:  
- Используйте замыкание для хранения состояния счётчика (например, внутри метода).  
- Реализуйте вложенную функцию для обработки логики фильтрации.  
- Определите `typedef` для типизации коллбэка кнопки и поля ввода.  

### Пример ожидаемого поведения:  
- Нажатие на кнопку увеличивает счётчик, используя замыкание.  
- Ввод текста фильтрует список элементов (например, отображаются только элементы, содержащие введённый текст).  

---

## Контрольные вопросы по теме  
1. **Что такое замыкание? Приведите пример его использования в Dart.**  
2. **Как отличаются замыкания и вложенные функции? В чём их преимущества?**  
3. **Как `typedef` упрощает работу с типами функций в Flutter?**  
4. **Можно ли передать вложенную функцию как параметр другой функции? Почему?**  
5. **Как использовать замыкание для хранения состояния в Flutter-приложении?**  

---

## Список литературы и ссылки для дополнительного чтения  
1. [Официальная документация Dart: Functions](https://dart.dev/guides/language/functions)  
2. [Flutter documentation on callbacks and closures](https://flutter.dev/docs/development/ui/advanced-topics/closures)  
3. [Блог Flutter: Working with closures in StatefulWidgets](https://medium.com/flutter/working-with-closures-in-flutter-7d6c40a41d5f)  
4. **Книга:** "Dart in Action" — Дэвид Хардинг, Ник Бернс (разделы о замыканиях и функциональных типах).  
5. [Советы по использованию `typedef` в Flutter](https://medium.com/flutter/using-typedef-to-make-your-flutter-code-cleaner-9b2d378f4c0d)  

---

## Заключение  
Замыкания и вложенные функции — мощные инструменты для разработки гибких и масштабируемых приложений на Dart и Flutter. Использование `typedef` позволяет улучшить читаемость кода, особенно при работе с коллбэками. Практика решения задач, описанных в данном разделе, поможет закрепить понимание этих концепций и применять их эффективно в реальных проектах.