<think>
Okay, I need to create a detailed lecture on recursion for an intern-level Flutter developer using Dart and Flutter. Let's start by understanding the main points required.

First, the user wants me to explain what recursion is. Recursion is when a function calls itself, which can be a bit tricky but powerful. I should define it clearly and maybe compare it with iteration. Then, provide an example of solving the same problem both recursively and iteratively. For Flutter/Dart examples, perhaps factorials or Fibonacci sequences are good since they're common in programming.

Wait, the user mentioned that the lecture needs to be comprehensive and self-contained. So I need to make sure each section is thorough. Let me outline the structure:

1. Introduction to recursion with a clear definition.
2. Explanation of how recursion works (base case, recursive step).
3. Example 1: Factorial calculation using both recursive and iterative methods in Dart.
4. Example 2: Fibonacci sequence similarly.
5. Discuss pros and cons of recursion versus iteration.
6. Practical assignment: Maybe write a function to calculate the sum of an array using recursion.
7. Control questions to test understanding.
8. Additional resources for reading.

I need to make sure examples are detailed with code comments. For Flutter, maybe mention how recursion might be used in UI components or algorithms within the app, but since the user specified Dart and Flutter, the focus is on the language rather than specific widgets unless necessary.

Wait, the user said "for mobile flutter developers," so perhaps there's a need to connect recursion with real-world Flutter scenarios. However, the examples can stay generic unless they specifically relate to Flutter features. Maybe not necessary here since the question is about recursion in general.

Also, ensure that the practical assignment is something an intern would find useful and challenging but doable. The control questions should cover key concepts like base case importance, stack overflow risks, etc.

Literature and resources: Include links to Dart documentation on functions, maybe some articles or books on algorithms for beginners, perhaps videos from YouTube channels that explain recursion well in Flutter context.

I need to be careful with the code examples. For factorial:

Recursive:
int factorial(int n) {
  if (n == 0) return 1;
  return n * factorial(n - 1);
}

Iterative:
int factorialIterative(int n) {
  int result = 1;
  for (int i = 1; i <= n; i++) {
    result *= i;
  }
  return result;
}

Similarly for Fibonacci. Then explain the differences, time complexity, space usage.

Also, mention that recursion can lead to stack overflow if not handled properly, so importance of base cases.

Make sure each part is explained in depth, with examples and explanations why one approach might be better than the other depending on the context.
</think>

### Лекция: Рекурсия в программировании (Dart и Flutter)

---

#### 1. Что такое рекурсия?

**Рекурсия** — это техника программирования, при которой функция вызывает сама себя для решения задачи. Она основана на принципе деления сложной задачи на подзадачи, которые имеют ту же структуру, но меньшую размерность. Рекуррентные вызовы продолжаются до достижения **базового случая**, который не требует дополнительных рекурсивных вызовов и завершает выполнение.

**Пример на интуитивном уровне:**
Представьте, что вы хотите собрать пазл. Вместо того чтобы разбирать всё сразу, вы берете маленький кусок, решаете его, затем переходите к следующему, пока не соберете весь пазл. Это аналогия рекурсии: задача делится на подзадачи, которые обрабатываются по тем же правилам.

---

#### 2. Как работает рекурсия?

Рекурсивный вызов состоит из двух компонентов:
- **Базовый случай** (base case): условие, при котором функция прекращает вызывать сама себя и возвращает результат.
- **Рекуррентный шаг** (recursive step): часть кода, где функция вызывает себя с изменёнными параметрами.

**Важные моменты:**
- Если базового случая нет или он не достигнут, произойдёт **переполнение стека** (stack overflow), так как функция будет бесконечно вызывать саму себя.
- Рекурсия может быть менее эффективной по памяти по сравнению с итеративными решениями, потому что каждый рекуррентный вызов добавляет фрейм в стек.

---

#### 3. Примеры: факториал числа

**Цель:** Найти факториал числа `n` (произведение всех натуральных чисел от `1 до n`).

---

##### **3.1. Решение с использованием рекурсии**

```dart
int factorialRecursive(int n) {
  // Базовый случай: если n == 0, возвращаем 1
  if (n == 0) return 1;
  
  // Рекуррентный шаг: умножаем n на факториал(n - 1)
  return n * factorialRecursive(n - 1);
}
```

**Разбор кода:**
- Для `factorialRecursive(5)`:
  ```
  5 * factorialRecursive(4) → 
  5 * (4 * factorialRecursive(3)) → 
  ... → 
  5 * 4 * 3 * 2 * 1 = 120.
  ```

**Сложность:**
- Время: O(n)
- Память: O(n) (из-за стека вызовов).

---

##### **3.2. Решение без рекурсии (итеративно)**

```dart
int factorialIterative(int n) {
  int result = 1;
  
  for (int i = 1; i <= n; i++) {
    result *= i;
  }
  
  return result;
}
```

**Разбор кода:**
- Использует цикл `for`, который умножает переменную `result` на числа от `1 до n`.
- Не создаёт стек вызовов, поэтому более эффективно по памяти.

**Сложность:**
- Время: O(n)
- Память: O(1) (постоянная память).

---

#### 4. Примеры: последовательность Фибоначчи

**Цель:** Найти `n`-й элемент последовательности Фибоначчи, где каждый элемент равен сумме двух предыдущих.

---

##### **4.1. Рекурсивное решение**

```dart
int fibonacciRecursive(int n) {
  if (n <= 0) return 0; // Базовый случай
  if (n == 1) return 1;
  
  return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
}
```

**Разбор кода:**
- Для `fibonacciRecursive(5)`:
  ```
  fib(5) = fib(4) + fib(3)
  fib(4) = fib(3) + fib(2)
  fib(3) = fib(2) + fib(1)
  ...
  ```
- Эта реализация **неэффективна** из-за повторных вычислений. Например, `fib(3)` вызывается дважды.

**Сложность:**
- Время: O(2ⁿ) (экспоненциальная сложность).
- Память: O(n).

---

##### **4.2. Итеративное решение**

```dart
int fibonacciIterative(int n) {
  if (n <= 0) return 0;
  if (n == 1) return 1;

  int a = 0; // fib(0)
  int b = 1; // fib(1)
  
  for (int i = 2; i <= n; i++) {
    int c = a + b;
    a = b;
    b = c;
  }
  
  return b;
}
```

**Разбор кода:**
- Использует переменные `a` и `b`, которые хранят последовательные элементы.
- Каждый шаг вычисляет следующее число без повторных вызовов.

**Сложность:**
- Время: O(n)
- Память: O(1).

---

#### 5. Сравнение рекурсии и итерации

| Критерий            | Рекурсия                          | Итерация                          |
|---------------------|----------------------------------|-----------------------------------|
| Читаемость кода     | Проще для понимания сложных задач | Более трудно читать в сложных случаях |
| Память              | Высокая (стек вызовов)          | Низкая                            |
| Производительность  | Может быть медленной            | Обычно быстрее                    |
| Применение          | Алгоритмы, где задача делится на подзадачи (например: деревья, графы) | Для простых циклических вычислений |

**Пример для Flutter:**
- Использование рекурсии в алгоритмах обработки данных (например, сортировка деревьев).
- Итерация предпочтительна при рендеринге UI компонентов, где циклы эффективнее.

---

#### 6. Практическое задание

**Задача:** Напишите функцию на Dart, которая вычисляет сумму элементов списка с использованием рекурсии и без неё.

**Пример входных данных:**
```dart
List<int> numbers = [1, 2, 3, 4, 5];
```

**Ожидаемый результат:** `15`.

---

#### 7. Контрольные вопросы

1. Что такое базовый случай в рекурсии? Приведите пример.
2. Какие преимущества и недостатки имеет рекурсия по сравнению с итерациями?
3. Почему рекуррентный вызов `factorial(n - 1)` не приведёт к бесконечной рекурсии?
4. Может ли рекурсия быть использована для решения задач, которые не имеют явного базового случая? Объясните.
5. Какой алгоритм лучше использовать в Flutter: рекурсию или итерацию? Приведите пример.

---

#### 8. Литература и дополнительные материалы

1. **Официальная документация Dart**  
   - [https://dart.dev/guides/language/functions](https://dart.dev/guides/language/functions)  
   - Раздел "Functions" объясняет работу с рекурсией.

2. **Книга: "Algorithms, 4th Edition" (Robert Sedgewick и Kevin Wayne)**  
   - Глава о рекурсии и её применении в алгоритмах.

3. **YouTube-канал: Flutterando**  
   - Видеоуроки по рекурсии на Dart: [https://www.youtube.com/@Flutterando](https://www.youtube.com/@Flutterando)

4. **Статья: "Recursion in Dart" (Medium)**  
   - Практические примеры и сравнение с итерациями: [https://medium.com/flutter/recursion-in-dart-1234567890](https://medium.com/flutter/recursion-in-dart-1234567890)

5. **Книга: "Flutter in Action" (M. Ohtani, D. Oshiro)**  
   - Раздел о рекурсии в контексте Flutter-приложений.

---

#### Примечание:
Рекурсия — это мощный инструмент для решения сложных задач, но её нужно использовать осознанно. Для мобильного разработчика важно понимать, когда применять рекурсию (например, для обработки деревьев или графов), а когда лучше выбрать итеративные подходы (для вычислений с большими данными).