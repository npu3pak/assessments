# Типовые проблемы многопоточности

---

## Введение
Многопоточность — ключевая концепция в мобильной разработке, но она сопряжена с рядом сложностей. Во Flutter, где асинхронные операции (сеть, файлы, UI) выполняются в изолятах или через `async/await`, проблемы синхронизации становятся критическими. Эта лекция охватывает типовые проблемы, их причины, последствия и решения.

---

## 1. Гонки данных (Race Conditions)
**Гонка данных** возникает, когда несколько потоков/изолятов обращаются к общему ресурсу без синхронизации, и результат зависит от порядка выполнения операций. Это приводит к некорректным данным и недетерминированному поведению.

### Пример: Некорректный счетчик
```dart
int _counter = 0;

Future<void> _unsafeIncrement() async {
  // Имитация долгой операции (например, запрос к API)
  await Future.delayed(Duration(milliseconds: 10));
  _counter++; 
}

void main() async {
  // Запускаем 100 асинхронных операций
  List<Future> futures = [];
  for (int i = 0; i < 100; i++) {
    futures.add(_unsafeIncrement());
  }
  await Future.wait(futures);
  print('Итог: $_counter'); // Результат меньше 100 (например, 95)
}
```
**Проблема**: Операция `_counter++` не атомарна. Два потока могут прочитать одно значение, увеличить его и записать, "потеряв" одно изменение.

**Решение**: Используйте блокировки из пакета `synchronized`.
```dart
import 'package:synchronized/synchronized.dart';

final _lock = Lock();
int _counter = 0;

Future<void> _safeIncrement() async {
  await _lock.synchronized(() async {
    await Future.delayed(Duration(milliseconds: 10));
    _counter++;
  });
}
```

---

## 2. Deadlock и Livelock
### Deadlock (Взаимная блокировка)
**Deadlock** возникает, когда потоки блокируют друг друга, ожидая ресурсы.  
**Условия возникновения**:
1. Взаимное исключение: ресурсы не могут быть разделены.
2. Удержание и ожидание: поток удерживает один ресурс и ждет другой.
3. Отсутствие вытеснения: ресурс нельзя отобрать.
4. Циклическое ожидание: потоки образуют цикл ожидания.

#### Пример Deadlock
```dart
import 'package:synchronized/synchronized.dart';

final lockA = Lock();
final lockB = Lock();

Future<void> task1() async {
  await lockA.synchronized(() async {
    await Future.delayed(Duration(seconds: 1));
    await lockB.synchronized(() {}); // Ждет lockB
  });
}

Future<void> task2() async {
  await lockB.synchronized(() async {
    await lockA.synchronized(() {}); // Ждет lockA
  });
}

// Запуск task1() и task2() приведет к зависанию.
```

**Профилактика**:
- Упорядочивайте блокировки: всегда захватывайте `lockA` перед `lockB`.
- Используйте таймауты:
  ```dart
  await lockA.synchronized(() async {
    bool gotLock = await lockB.lock(timeout: Duration(seconds: 2));
    if (!gotLock) {
      // Обработка ошибки
    }
  });
  ```

### Livelock (Активная блокировка)
**Livelock** — потоки активно "работают", но не продвигаются.  
**Пример**: Два изолята пытаются согласовать состояние, отправляя друг другу корректировки, но бесконечно пересогласовывают данные без прогресса.

```dart
// Изолят 1
void isolate1(SendPort port2) {
  port2.send('Данные версии 1');
  port2.listen((message) {
    if (message == 'Конфликт') {
      port2.send('Данные версии 2'); // Реагирует на конфликт
    }
  });
}

// Изолят 2
void isolate2(SendPort port1) {
  port1.listen((message) {
    if (message is String && message.contains('версии')) {
      port1.send('Конфликт'); // Всегда отвечает конфликтом
    }
  });
}
```

**Решение**: Ввести алгоритм разрешения конфликтов (например, приоритет версий).

---

## 3. Инверсия приоритетов
**Инверсия приоритетов** — низкоприоритетный поток удерживает ресурс, нужный высокоприоритетному.  
**Пример во Flutter**:
- Главный поток UI (высокий приоритет) ожидает доступ к файлу, который заблокирован фоновым потоком (низкий приоритет).
- Результат: "Зависание" интерфейса.

**Решение**: Минимизируйте блокировку главного потока. Используйте асинхронные операции без блокировки:
```dart
Future<void> readFile() async {
  // Используйте асинхронные методы (например, File.readAsString)
  String content = await File('data.txt').readAsString();
  setState(() => _text = content);
}
```

---

## 4. Голодание (Starvation)
**Голодание** — поток долго не получает доступ к ресурсу из-за высокого спроса.  
**Пример**: Фоновый поток не может записать данные в БД, так как главный поток постоянно выполняет операции чтения.

```dart
// Плохой пример: главный поток монополизирует доступ
Future<void> _loadData() async {
  while (true) {
    var data = await _database.query('SELECT * FROM table');
    updateUI(data);
    await Future.delayed(Duration(milliseconds: 10));
  }
}
```

**Решение**: Используйте приоритеты или ограничьте частоту операций:
```dart
// Используйте Throttle для ограничения запросов
throttle(() {
  _database.query('SELECT ...');
}, duration: Duration(seconds: 1));
```

---

## 5. Критические секции
**Критическая секция** — участок кода, где происходит доступ к общему ресурсу. Ее необходимо защищать от одновременного выполнения.

### Реализация во Flutter
1. **Блокировки** (пакет `synchronized`):
   ```dart
   final _lock = Lock();
   Future<void> safeOperation() async {
     await _lock.synchronized(() async {
       // Работа с общим ресурсом
     });
   }
   ```
2. **Атомарные операции** (для простых типов):
   ```dart
   import 'package:atomic/atomic.dart';
   final _counter = AtomicInt(0);
   void increment() => _counter.increment();
   ```

---

## 6. Throttle и Debounce (библиотека `throttled`)
Пакет [`throttled`](https://pub.dev/packages/throttled) предоставляет инструменты для контроля частоты операций.

### Throttle
**Throttle** — выполнить операцию не чаще, чем раз в указанный интервал.  
**Пример**: Ограничение запросов при скролле.
```dart
import 'package:throttled/throttled.dart';

final throttler = Throttler(duration: Duration(seconds: 1));

void onScroll() {
  throttler.throttle(() {
    fetchNextPage(); // Вызовется не чаще 1 раза в секунду
  });
}
```

### Debounce
**Debounce** — выполнить операцию после паузы в указанном интервале.  
**Пример**: Поиск при вводе текста.
```dart
final debouncer = Debouncer(duration: Duration(milliseconds: 500));

void onSearchTextChanged(String query) {
  debouncer.debounce(() {
    search(query); // Вызовется через 500 мс после последнего ввода
  });
}
```

---

## 7. Пакет `synchronized`
Пакет [`synchronized`](https://pub.dev/packages/synchronized) реализует блокировки для синхронизации асинхронного кода.

### Основные возможности:
- **Блокировки с таймаутом**:
  ```dart
  bool locked = await _lock.synchronizedTimeout(
    Duration(seconds: 2), 
    () async { ... }
  );
  ```
- **Рекурсивные блокировки** (один поток может захватывать один и тот же Lock несколько раз).
- **Очередь операций**: Запросы на блокировку выполняются в порядке поступления.

---

## Практическое задание
1. **Гонка данных**: 
   - Создайте приложение с двумя кнопками, каждая запускает 100 асинхронных операций инкремента счетчика.
   - Покажите, что без синхронизации результат некорректный.
   - Исправьте с помощью `synchronized`.

2. **Debounce для поиска**:
   - Реализуйте поле ввода с поиском, где запрос к API выполняется через 800 мс после остановки ввода.
   - Используйте пакет `throttled`.

3. **Deadlock**:
   - Смоделируйте взаимную блокировку двух изолятов.
   - Исправьте упорядочиванием блокировок.

---

## Контрольные вопросы
1. Чем отличается Deadlock от Livelock? Приведите примеры.
2. Как Throttle помогает избежать проблем с производительностью?
3. Почему операция `_counter++` не атомарна?
4. Как избежать инверсии приоритетов в UI-потоке?
5. Объясните принцип работы критической секции.

---

## Литература
1. **Документация Dart**: [Concurrency](https://dart.dev/guides/language/concurrency)
2. **Пакет `synchronized`**: [Примеры использования](https://pub.dev/packages/synchronized)
3. **Статья**: [Flutter: Async Patterns](https://medium.com/flutter-community/async-patterns-in-flutter-14e84767b12b)
4. **Книга**: [Flutter in Action](https://www.manning.com/books/flutter-in-action)

---