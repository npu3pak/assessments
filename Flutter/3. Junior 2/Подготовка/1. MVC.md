Паттерн MVC в разработке на Flutter

---

## **1. Историческая сводка**
MVC (Model-View-Controller) — один из старейших архитектурных паттернов, разработанный в 1970-х годах для языка Smalltalk. Его цель — разделение ответственности между компонентами:
- **Model** (данные и бизнес-логика),
- **View** (отображение информации),
- **Controller** (обработка пользовательского ввода).

С развитием GUI и мобильной разработки MVC адаптировался под новые платформы, включая Flutter. В мобильных приложениях паттерн помогает управлять сложностью, изолируя логику, UI и данные.

---

## **2. Слой Model**
**Назначение**:  
- Хранение данных.
- Реализация бизнес-логики (например, валидация, вычисления).
- Взаимодействие с внешними источниками (API, базы данных).

**Пример на Dart**:
```dart
class User {
  final String id;
  final String email;
  final String name;

  User({required this.id, required this.email, required this.name});

  // Бизнес-логика: валидация email
  bool isValidEmail() {
    return RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$').hasMatch(email);
  }
}

// Репозиторий для работы с данными (например, API)
class UserRepository {
  Future<User> fetchUser(String userId) async {
    // Запрос к API...
  }
}
```

**Что нельзя делать**:
- Добавлять логику, связанную с UI (например, форматирование текста для отображения).
- Прямо обновлять View из Model.

---

## **3. Слой View**
**Назначение**:
- Отображение данных (из Model).
- Обработка пользовательских действий (нажатия, жесты).
- Передача событий в Controller.

**Пример на Flutter**:
```dart
class UserProfileView extends StatelessWidget {
  final User user;
  final VoidCallback onEditPressed;

  const UserProfileView({
    required this.user,
    required this.onEditPressed,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Name: ${user.name}'),
        Text('Email: ${user.email}'),
        ElevatedButton(
          onPressed: onEditPressed, // Событие передается в Controller
          child: Text('Edit Profile'),
        ),
      ],
    );
  }
}
```

**Ошибки**:
- Размещение бизнес-логики в виджетах (например, валидация в `build`).
- Прямое обращение к Model из View.

---

## **4. Слой Controller**
**Назначение**:
- Обработка событий от View.
- Обновление Model.
- Управление состоянием View (например, обновление данных).

**Пример на Dart**:
```dart
class UserController {
  final UserRepository userRepository;
  User? _currentUser;

  UserController({required this.userRepository});

  Future<void> loadUser(String userId) async {
    _currentUser = await userRepository.fetchUser(userId);
  }

  void handleEditButtonPressed() {
    // Например, открытие экрана редактирования
  }
}
```

**Связь с View**:
```dart
class UserProfileScreen extends StatefulWidget {
  @override
  _UserProfileScreenState createState() => _UserProfileScreenState();
}

class _UserProfileScreenState extends State<UserProfileScreen> {
  final UserController _controller = UserController(userRepository: UserRepository());

  @override
  void initState() {
    super.initState();
    _controller.loadUser('123');
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: UserProfileView(
        user: _controller.currentUser ?? User.empty(),
        onEditPressed: _controller.handleEditButtonPressed,
      ),
    );
  }
}
```

---

## **5. Особенности MVVM**
MVVM (Model-View-ViewModel) — альтернатива MVC, популярная в Flutter.  
**Ключевые отличия**:
- **ViewModel** вместо Controller: содержит состояние View и логику презентации.
- **Data Binding**: автоматическое обновление View при изменении ViewModel (например, через `Streams` или `ChangeNotifier`).

**Пример с `ChangeNotifier`**:
```dart
class UserViewModel extends ChangeNotifier {
  User? _user;
  final UserRepository userRepository;

  UserViewModel({required this.userRepository});

  User? get user => _user;

  Future<void> loadUser(String userId) async {
    _user = await userRepository.fetchUser(userId);
    notifyListeners(); // Уведомление View об обновлении
  }
}

// В View:
ValueListenableBuilder<User?>(
  valueListenable: userViewModel,
  builder: (context, user, _) {
    return Text(user?.name ?? 'Loading...');
  },
)
```

---

## **6. Примеры неправильной реализации**
**Ошибка 1: Бизнес-логика в View**
```dart
// ❌ Неправильно: валидация внутри виджета
Widget build(BuildContext context) {
  bool isValid = RegExp(r'^...').hasMatch(_emailController.text);
  return Text(isValid ? 'Valid' : 'Invalid');
}
```

**Ошибка 2: Толстый Controller**  
Контроллер, который делает всё: обрабатывает данные, управляет навигацией, работает с API и UI.

**Ошибка 3: Прямые связи Model-View**  
```dart
// ❌ Неправильно: View напрямую меняет Model
ElevatedButton(
  onPressed: () {
    user.name = 'New Name'; // Прямое изменение Model
  },
)
```

---

## **7. Аргументированная критика MVC**
**Недостатки**:
- **Сложность масштабирования**: В больших проектах Controller может превратиться в "божественный объект".
- **Тесная связь**: View и Controller часто зависят друг от друга, что усложняет тестирование.
- **Отсутствие стандарта**: В Flutter нет строгой реализации MVC, что приводит к противоречивым решениям.

**Когда использовать**:
- Небольшие проекты.
- Для обучения (паттерн прост для понимания).

---

## **8. Альтернативы MVC**
1. **BLoC (Business Logic Component)**  
   Использует потоки (`Stream`) для управления состоянием. Отделяет бизнес-логику от UI.
   ```dart
   class UserBloc {
     final _userController = StreamController<User>();
     Stream<User> get userStream => _userController.stream;

     void loadUser(String userId) async {
       User user = await userRepository.fetchUser(userId);
       _userController.add(user);
     }
   }
   ```

2. **Provider**  
   Упрощает управление состоянием через `InheritedWidget`. Часто используется с `ChangeNotifier`.

3. **Redux**  
   Предсказуемое управление состоянием через единый Store и Actions.

4. **MVVM**  
   Подходит для сложных UI с частыми обновлениями (например, формы с валидацией).

---

## **9. Советы по выбору архитектуры**
- **Для Junior**: Начните с MVC или Provider, чтобы понять основы.
- **Для больших проектов**: Выбирайте BLoC или Redux.
- **Для реактивных UI**: MVVM с `Streams` или `RxDart`.

---

## **10. Заключение**
MVC — фундаментальный паттерн, который учит разделению ответственности. Однако во Flutter он часто дополняется или заменяется более специализированными подходами (BLoC, MVVM). Ключевые принципы:
- Изоляция бизнес-логики от UI.
- Минимизация связей между компонентами.
- Использование подходящих инструментов для вашего проекта.

**Практическое задание**:  
Реализуйте экран входа с использованием MVC:
- Model: `User`, `AuthRepository`.
- View: Поля для email/пароля, кнопка "Войти".
- Controller: Обработка ввода, вызов `AuthRepository.login()`.

**Для дальнейшего чтения**: 
- Охота на мифический MVC. Обзор, возвращение к первоисточникам и про то, как анализировать и выводить шаблоны самому
https://habr.com/ru/articles/321050/