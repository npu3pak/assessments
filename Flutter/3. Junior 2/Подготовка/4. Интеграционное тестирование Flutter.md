(Due to technical issues, the search service is temporarily unavailable.)

# Интеграционное тестирование в Flutter 

## 1. Введение

### 1.1 Интеграционное тестирование vs UI-тестирование
**Интеграционное тестирование** проверяет взаимодействие между компонентами системы: UI, бизнес-логикой, внешними сервисами (API, базы данных).  
**UI-тестирование** фокусируется на проверке визуальных элементов и их поведения.  

**Различия в общем случае**:
- UI-тесты могут быть частью интеграционных, но не всегда охватывают интеграцию с внешними системами.  
- Интеграционные тесты включают проверку сценариев, где задействованы несколько модулей (например, авторизация через API и отображение данных в UI).

**Во Flutter** эти понятия часто объединяются, так как UI-тесты автоматически проверяют интеграцию с логикой приложения.

---

## 2. Назначение и возможности интеграционного тестирования

### 2.1 Цели:
- Проверить корректность работы приложения в условиях, приближенных к реальным.  
- Обнаружить ошибки взаимодействия между слоями (UI → логика → данные).  
- Убедиться, что навигация, анимации и состояния работают правильно.  

### 2.2 Ограничения:
- Требуют много времени на выполнение.  
- Зависимость от внешних сервисов (например, тестовый API может быть недоступен).  
- Сложность диагностики ошибок из-за большого охвата функционала.

---

## 3. Виды тестирования и пирамида

### 3.1 Пирамида тестирования
``` 
          / Ручное тестирование (5%)
         / Интеграционные тесты (15%)
        / Widget-тесты (20%)
-------/ Unit-тесты (60%)
```
- **Unit-тесты**: Проверка отдельных функций/классов.  
- **Widget-тесты**: Изолированное тестирование виджетов.  
- **Интеграционные тесты**: Проверка всего приложения целиком.  
- **Ручное тестирование**: Проверка сложных сценариев, которые сложно автоматизировать (например, UX/UI-ревью).

**Другие виды**:
- **Дымовые тесты (Smoke tests)**: Базовая проверка работоспособности после сборки.  
- **Регрессионные тесты**: Проверка, что новые изменения не сломали старый функционал.

---

## 4. Методы черного и серого ящиков

### 4.1 Черный ящик
- Тестирование без знания внутренней реализации.  
- Пример: Проверка, что введенный текст в поле `Email` сохраняется.  

### 4.2 Серый ящик
- Тестирование с частичным знанием внутренней логики.  
- Пример: Проверка, что после нажатия кнопки вызывается метод `saveUserData()`.

**В интеграционных тестах** Flutter чаще используется подход черного ящика.

---

## 5. Фреймворки для интеграционного тестирования

### 5.1 `integration_test` (официальный пакет Flutter)
- Поддержка Android и iOS.  
- Интеграция с `WidgetTester` для управления виджетами.  
- Совместимость с инструментами CI/CD.

### 5.2 Другие фреймворки:
- **Appium**: Кроссплатформенный инструмент для автоматизации мобильных приложений.  
- **WebdriverIO (WDIO)**: Фреймворк для тестирования веб- и мобильных приложений с поддержкой Appium.

---

## 6. Полный пример интеграционного теста

### 6.1 Тестируемое приложение
**main.dart** (упрощенное приложение с экраном логина):
```dart
import 'package:flutter/material.dart';

void main() => runApp(MyApp());

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: LoginScreen(),
    );
  }
}

class LoginScreen extends StatefulWidget {
  @override
  _LoginScreenState createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final TextEditingController _emailController = TextEditingController();
  final TextEditingController _passwordController = TextEditingController();

  void _login() {
    if (_emailController.text == 'test@example.com' && _passwordController.text == 'password123') {
      Navigator.push(context, MaterialPageRoute(builder: (_) => HomeScreen()));
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          children: [
            TextField(
              key: Key('email'),
              controller: _emailController,
              decoration: InputDecoration(labelText: 'Email'),
            ),
            TextField(
              key: Key('password'),
              controller: _passwordController,
              obscureText: true,
              decoration: InputDecoration(labelText: 'Password'),
            ),
            ElevatedButton(
              key: Key('loginButton'),
              onPressed: _login,
              child: Text('Login'),
            ),
          ],
        ),
      ),
    );
  }
}

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Главный экран')),
      body: Center(child: Text('Успешный вход!')),
    );
  }
}
```

### 6.2 Тест (integration_test/app_test.dart)
```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:flutter/material.dart';
import 'package:your_app/main.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  testWidgets('Тест успешного входа', (WidgetTester tester) async {
    // Запуск приложения
    await tester.pumpWidget(MyApp());

    // Поиск виджетов по ключам
    final emailField = find.byKey(Key('email'));
    final passwordField = find.byKey(Key('password'));
    final loginButton = find.byKey(Key('loginButton'));

    // Ввод данных
    await tester.enterText(emailField, 'test@example.com');
    await tester.enterText(passwordField, 'password123');
    await tester.tap(loginButton);

    // Ожидание анимации перехода
    await tester.pumpAndSettle();

    // Проверка перехода на главный экран
    expect(find.text('Главный экран'), findsOneWidget);
  });
}
```

---

## 7. Запуск интеграционных тестов

### 7.1 Локальный запуск на Android
```bash
flutter test integration_test/app_test.dart -d emulator-5554
```

### 7.2 Запуск на iOS
```bash
flutter test integration_test/app_test.dart -d iPhone13
```

### 7.3 Платформо-специфичные нюансы
- **Android**: Убедитесь, что эмулятор запущен и не заблокирован.  
- **iOS**: Для симуляторов используйте корректные идентификаторы устройств (проверьте через `flutter devices`).

---

## 8. Практическое задание

**Задача**: Добавьте в приложение экран профиля с полем `Имя`, которое сохраняется через `PageStorage`. Напишите интеграционный тест, который:
1. Вводит имя в поле на экране профиля.  
2. Переходит на другой экран и обратно.  
3. Проверяет, что введенное имя сохранилось.

**Структура приложения**:
- Экран A: Поле `Имя` и кнопка `Перейти к экрану B`.  
- Экран B: Кнопка `Вернуться`.  

**Подсказка**: Используйте `PageStorageKey` и `PageStorageBucket`.

---

## 9. Контрольные вопросы

1. Какие слои приложения затрагивает интеграционное тестирование?  
2. Почему ручное тестирование находится на вершине пирамиды?  
3. Как Appium взаимодействует с Flutter-приложениями?  
4. Что делает метод `pumpAndSettle()`?  
5. Как тестировать сценарии с ошибками (например, неверный пароль)?

---

## 10. Литература

1. [Официальная документация Flutter: Integration tests](https://docs.flutter.dev/testing/integration-tests)  
2. [Appium: Getting Started with Flutter](https://appium.io/docs/en/writing-running-appium/flutter/)  
3. [Примеры интеграционных тестов](https://github.com/flutter/flutter/tree/main/packages/integration_test)  
4. [Статья: "Тестирование в Flutter от А до Я"](https://habr.com/ru/articles/522334/)  
